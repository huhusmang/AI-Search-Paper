[
    {
        "@score": "1",
        "@id": "4117871",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "17/5702-1",
                        "text": "Sangho Lee 0001"
                    },
                    {
                        "@pid": "155/0040",
                        "text": "Hyungsub Kim"
                    },
                    {
                        "@pid": "46/2217",
                        "text": "Jong Kim 0001"
                    }
                ]
            },
            "title": "Identifying Cross-origin Resource Status Using Application Cache.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/0001KK15",
            "ee": "https://www.ndss-symposium.org/ndss2015/identifying-cross-origin-resource-status-using-application-cache",
            "url": "https://dblp.org/rec/conf/ndss/0001KK15",
            "abstract": "HTML5 Application Cache (AppCache) allows web applications to cache their same- and cross-origin resources in the local storage of a web browser to enable offline access. However, cross-origin resource caching in AppCache has potential security and privacy problems. In this paper, we consider a novel web privacy attack that exploits cross-origin AppCache. Our attack allows a remote web attacker to exploit a victim web browser to exactly identify the status of target URLs: existence, redirection, or error. Especially, our attack can be performed without using client-side scripts, can concurrently identify the status of multiple URLs, and can exactly identify the redirections of target URLs. We further demonstrate advanced attacks that leverage the basic attack to de-anonymize and fingerprint victims. First, we determine the login status of a victim web browser by identifying URL redirections or errors due to absent or erroneous login information. Second, we probe internal web servers located in the local network of a victim web browser by identifying URL existence. We also suggest an effective countermeasure to mitigate the proposed attacks.",
            "keywords": [
                "Web Privacy",
                "Cross-origin Resource Sharing",
                "Application Cache",
                "URL Status Identification",
                "De-anonymization Attacks"
            ]
        },
        "url": "URL#4117871",
        "sema_paperId": "c340b57b42cda01634837f061cf017502ade8572"
    },
    {
        "@score": "1",
        "@id": "4117872",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "24/11505",
                        "text": "Pieter Agten"
                    },
                    {
                        "@pid": "13/86",
                        "text": "Wouter Joosen"
                    },
                    {
                        "@pid": "85/6647",
                        "text": "Frank Piessens"
                    },
                    {
                        "@pid": "04/8280",
                        "text": "Nick Nikiforakis"
                    }
                ]
            },
            "title": "Seven Months&apos; Worth of Mistakes: A Longitudinal Study of Typosquatting Abuse.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/AgtenJPN15",
            "ee": "https://www.ndss-symposium.org/ndss2015/seven-months-worth-mistakes-longitudinal-study-typosquatting-abuse",
            "url": "https://dblp.org/rec/conf/ndss/AgtenJPN15",
            "abstract": "Typosquatting is the act of purposefully registering a domain name that is a mistype of a popular domain name. It is a concept that has been known and studied for over 15 years, yet still thoroughly practiced up until this day. While previous typosquatting studies have always taken a snapshot of the typosquatting landscape or base their longitudinal results only on domain registration data, we present the first contentbased, longitudinal study of typosquatting. We collected data about the typosquatting domains of the 500 most popular sites of the Internet every day, for a period of seven months, and we use this data to establish whether previously discovered typosquatting trends still hold today, and to provide new results and insights in the typosquatting landscape. In particular we reveal that, even though 95% of the popular domains we investigated are actively targeted by typosquatters, only few trademark owners protect themselves against this practice by proactively registering their own typosquatting domains. We take advantage of the longitudinal aspect of our study to show, among other results, that typosquatting domains change hands from typosquatters to legitimate owners and vice versa, and that typosquatters vary their monetization strategy by hosting different types of pages over time. Our study also reveals that a large fraction of typosquatting domains can be traced back to a small group of typosquatting page hosters and that certain top-level domains are much more prone to typosquatting than others.",
            "keywords": [
                "Typosquatting",
                "Domain Registration",
                "Trademark Protection",
                "Monetization Strategies",
                "Longitudinal Study"
            ]
        },
        "url": "URL#4117872",
        "sema_paperId": "bc3647343ff2667a76e50fbf2624e4e5cfdc12d0"
    },
    {
        "@score": "1",
        "@id": "4117873",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "161/0701",
                        "text": "Michalis Athanasakis"
                    },
                    {
                        "@pid": "51/4565",
                        "text": "Elias Athanasopoulos"
                    },
                    {
                        "@pid": "09/1231",
                        "text": "Michalis Polychronakis"
                    },
                    {
                        "@pid": "44/3319",
                        "text": "Georgios Portokalidis"
                    },
                    {
                        "@pid": "33/2939",
                        "text": "Sotiris Ioannidis"
                    }
                ]
            },
            "title": "The Devil is in the Constants: Bypassing Defenses in Browser JIT Engines.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/AthanasakisAPPI15",
            "ee": "https://www.ndss-symposium.org/ndss2015/devil-constants-bypassing-defenses-browser-jit-engines",
            "url": "https://dblp.org/rec/conf/ndss/AthanasakisAPPI15",
            "abstract": "Return-oriented programming (ROP) has become the dominant form of vulnerability exploitation in both user and kernel space. Many defenses against ROP exploits exist, which can significantly raise the bar against attackers. Although protecting existing code, such as applications and the kernel, might be possible, taking countermeasures against dynamic code, i.e., code that is generated only at run-time, is much harder. Attackers have already started exploiting Just-in-Time (JIT) engines, available in all modern browsers, to introduce their (shell)code (either native code or re-usable gadgets) during JIT compilation, and then taking advantage of it. Recognizing this immediate threat, browser vendors started employing defenses for hardening their JIT engines. In this paper, we show that\u2014no matter the employed defenses\u2014JIT engines are still exploitable using solely dynamically generated gadgets. We demonstrate that dynamic ROP payload construction is possible in two modern web browsers without using any of the available gadgets contained in the browser binary or linked libraries. First, we exploit an open source JIT engine (Mozilla Firefox) by feeding it malicious JavaScript, which once processed generates all required gadgets for running any shellcode successfully. Second, we exploit a proprietary JIT engine, the one in the 64-bit Microsoft Internet Explorer, which employs many undocumented, specially crafted defenses against JIT exploitation. We manage to bypass all of them and create the required gadgets for running any shellcode successfully. All defensive techniques are documented in this paper to assist other researchers. Furthermore, besides showing how to construct ROP gadgets on-the-fly, we also show how to discover them on-the-fly, rendering current randomization schemes ineffective. Finally, we perform an analysis of the most important defense currently employed, namely constant blinding, which shields all three-byte or larger immediate values in the JIT buffer for hindering the construction of ROP gadgets. Our analysis suggests that extending constant blinding to all immediate values (i.e., shielding 1-byte and 2-byte constants) dramatically decreases the JIT engine\u2019s performance, introducing up to 80% additional instructions.",
            "keywords": [
                "Just-in-Time (JIT) Exploitation",
                "Return-Oriented Programming (ROP)",
                "Dynamic Code Generation",
                "JIT Engine Defenses",
                "Constant Blinding"
            ]
        },
        "url": "URL#4117873",
        "sema_paperId": "fd63b44c7b4a762c4daca7c79655c4edbd7b298b"
    },
    {
        "@score": "1",
        "@id": "4117874",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "32/3440",
                        "text": "Lujo Bauer"
                    },
                    {
                        "@pid": "57/967",
                        "text": "Shaoying Cai"
                    },
                    {
                        "@pid": "89/161-1",
                        "text": "Limin Jia 0001"
                    },
                    {
                        "@pid": "95/10638",
                        "text": "Timothy Passaro"
                    },
                    {
                        "@pid": "133/2054",
                        "text": "Michael Stroucken"
                    },
                    {
                        "@pid": "39/5423-1",
                        "text": "Yuan Tian 0001"
                    }
                ]
            },
            "title": "Run-time Monitoring and Formal Analysis of Information Flows in Chromium.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/BauerCJPST15",
            "ee": "https://www.ndss-symposium.org/ndss2015/run-time-monitoring-and-formal-analysis-information-flows-chromium",
            "url": "https://dblp.org/rec/conf/ndss/BauerCJPST15",
            "abstract": "Web browsers are a key enabler of a wide range of online services, from shopping and email to banking and health services. Because these services frequently involve handling sensitive data, a wide range of web browser security policies and mechanisms has been implemented or proposed to mitigate the dangers posed by malicious code and sites. This paper describes an approach for specifying and enforcing flexible information-flow policies on the Chromium web browser. Complementing efforts that focus on information-flow enforcement on JavaScript, our approach focuses on an existing browser and encompasses a broad range of browser features, from pages and scripts to DOM elements, events, persistent state, and extensions. In our approach, which is a coarse-grained, light-weight implementation of taint tracking, entities in the browser are annotated with information-flow labels that specify policy and track information flows. We develop a detailed formal model of our approach, for which we prove noninterference. We also develop a corresponding prototype system built on top of Chromium. We demonstrate, and experimentally confirm, that the system can enforce many existing browser policies, as well as practically useful policies beyond those enforceable in standard web browsers.",
            "keywords": [
                "Web Browser Security",
                "Information Flow Policies",
                "Taint Tracking",
                "Chromium",
                "Formal Analysis"
            ]
        },
        "url": "URL#4117874",
        "sema_paperId": "1f973b2799544c6c30981d821f6db29ba5fb237e"
    },
    {
        "@score": "1",
        "@id": "4117875",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "80/3503",
                        "text": "Karthikeyan Bhargavan"
                    },
                    {
                        "@pid": "121/1113",
                        "text": "Antoine Delignat-Lavaud"
                    },
                    {
                        "@pid": "p/AlfredoPironti",
                        "text": "Alfredo Pironti 0001"
                    }
                ]
            },
            "title": "Verified Contributive Channel Bindings for Compound Authentication.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/BhargavanDP15",
            "ee": "https://www.ndss-symposium.org/ndss2015/verified-contributive-channel-bindings-compound-authentication",
            "url": "https://dblp.org/rec/conf/ndss/BhargavanDP15",
            "abstract": "Compound authentication protocols, such as EAP in IKEv2 or SASL over TLS, bind application-level authentication to a transport-level authenticated channel in order to obtain strong composite authentication under weak trust assumptions. Despite their wide deployment, these protocols remain poorly understood, leading to several credential forwarding man-in-themiddle attacks. We present formal models for several compound authentication protocols, and analyze them against a rich threat model that includes compromised certificates, leaked session keys, and Diffie-Hellman small subgroup confinement. Our analysis uncovers new compound authentication attacks on TLS renegotiation, SSH re-exchange, IKEv2 resumption, and a number of other channel binding proposals. We propose new channel bindings and formally evaluate their effectiveness using the automated symbolic cryptographic protocol verifier, ProVerif. In particular, we present the first formal models that can reconstruct the recently published triple handshake attacks on TLS, and the first automated analysis of its proposed countermeasure. I. COMPOUND AUTHENTICATION Mutual authentication of clients and servers is an important security goal of any distributed system architecture. To this end, cryptographic protocols such as Transport Layer Security (TLS), Secure Shell (SSH), and Internet Protocol Security (IPsec) offer several mutual authentication modes based on well-studied cryptographic constructions called Authenticated Key Exchanges (AKEs). However, a common deployment scenario for these protocols, as depicted in Figure 1, does not use mutual authentication. Instead the transport-level protocol authenticates only the server and establishes a unilaterally-authenticated secure channel where the client is anonymous. The client (or user) is authenticated by a subsequent application-level authentication protocol that is tunneled within the transport channel. The composition of these two protocols aims to provide compound authentication: a guarantee that the same two participants engaged in both protocols, and hence both agree upon the identities of each other (and other session parameters). Examples of such compound authentication protocols are widespread, and we list some that use TLS as the transportlevel protocol. TLS servers almost universally use only server User u",
            "keywords": [
                "Compound Authentication",
                "Channel Binding",
                "Cryptographic Protocols",
                "Credential Forwarding Attacks",
                "TLS Renegotiation Vulnerabilities"
            ]
        },
        "url": "URL#4117875",
        "sema_paperId": "7666a45d4474633d4abd0a77b4b39d7a9f0e881c"
    },
    {
        "@score": "1",
        "@id": "4117876",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "52/8356",
                        "text": "Igor Bilogrevic"
                    },
                    {
                        "@pid": "10/3024",
                        "text": "K\u00e9vin Huguenin"
                    },
                    {
                        "@pid": "86/5508",
                        "text": "Stefan Mihaila"
                    },
                    {
                        "@pid": "20/3101",
                        "text": "Reza Shokri"
                    },
                    {
                        "@pid": "h/JPHubaux",
                        "text": "Jean-Pierre Hubaux"
                    }
                ]
            },
            "title": "Predicting Users&apos; Motivations behind Location Check-Ins and Utility Implications of Privacy Protection Mechanisms.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "closed",
            "key": "conf/ndss/BilogrevicHMSH15",
            "doi": "10.14722/NDSS.2015.23032",
            "ee": "https://doi.org/10.14722/ndss.2015.23032",
            "url": "https://dblp.org/rec/conf/ndss/BilogrevicHMSH15",
            "abstract": "Location check-ins contain both geographical and semantic information about the visited venues, in the form of tags (e.g., \u201crestaurant\u201d). Such data might reveal some personal information about users beyond what they actually want to disclose, hence their privacy is threatened. In this paper, we study users\u2019 motivations behind location check-ins, and we quantify the effect of a privacy-preserving technique (i.e., generalization) on the perceived utility of check-ins. By means of a targeted user study on Foursquare (N = 77), we show that the motivation behind Foursquare check-ins is a mediator of the loss of utility caused by generalization. Using these findings, we propose a machine learning method for determining the motivation behind each check-in, and we design a motivation-based predictive model for utility. Our results show that the model accurately predicts the loss of utility caused by semantic and geographical generalization; this model enables the design of utility-aware, privacy-enhancing mechanisms in location-based social networks.",
            "keywords": [
                "Location-Based Social Networks",
                "User Motivations",
                "Privacy Protection",
                "Utility Loss",
                "Generalization Techniques"
            ]
        },
        "url": "URL#4117876",
        "sema_paperId": "c55ccf266a3aac3f4b260f6fbedfe376e78a0d69"
    },
    {
        "@score": "1",
        "@id": "4117877",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "30/8037",
                        "text": "Jeremiah Blocki"
                    },
                    {
                        "@pid": "05/6177",
                        "text": "Saranga Komanduri"
                    },
                    {
                        "@pid": "03/1595",
                        "text": "Lorrie Faith Cranor"
                    },
                    {
                        "@pid": "d/AnupamDatta",
                        "text": "Anupam Datta"
                    }
                ]
            },
            "title": "Spaced Repetition and Mnemonics Enable Recall of Multiple Strong Passwords.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/BlockiKCD15",
            "ee": "https://www.ndss-symposium.org/ndss2015/spaced-repetition-and-mnemonics-enable-recall-multiple-strong-passwords",
            "url": "https://dblp.org/rec/conf/ndss/BlockiKCD15",
            "abstract": "We report on a user study that provides evidence that spaced repetition and a specific mnemonic technique enable users to successfully recall multiple strong passwords over time. Remote research participants were asked to memorize 4 Person-Action-Object (PAO) stories where they chose a famous person from a drop-down list and were given machine-generated random action-object pairs. Users were also shown a photo of a scene and asked to imagine the PAO story taking place in the scene (e.g., Bill Gates swallowing bike on a beach). Subsequently, they were asked to recall the action-object pairs when prompted with the associated scene-person pairs following a spaced repetition schedule over a period of 100+ days. While we evaluated several spaced repetition schedules, the best results were obtained when users initially returned after 12 hours and then in 1.5x increasing intervals: 77.1% of the participants successfully recalled all 4 stories in all 9 tests over a period of 102 days. Much of the forgetting happened in the first test period (12 hours): on average 94.9% of the participants who had remembered the stories in earlier rounds successfully remembered them in subsequent rounds. These findings, coupled with recent results on naturally rehearsing password schemes, suggest that 4 PAO stories could be used to create usable and strong passwords for 14 sensitive accounts following this spaced repetition schedule, possibly with a few extra upfront rehearsals. In addition, we find statistically significant evidence that initially (8 tests over 64 days) users who were asked to memorize 4 PAO stories outperform users who are given 4 random action-object pairs, but eventually (9 tests over 128 days) the advantage is not significant. Furthermore, there is an interference effect across multiple PAO stories: the recall rate of 100% for participants who were asked to memorize 1 or 2 PAO stories is significantly better than that for 4 PAO stories. These findings yield concrete advice for improving constructions of password management schemes and future user studies.",
            "pdf_url": "https://www.ndss-symposium.org/wp-content/uploads/2017/09/08_1_1.pdf",
            "keywords": [
                "Spaced Repetition",
                "Mnemonics",
                "Password Recall",
                "Person-Action-Object Stories",
                "Memory Retention"
            ]
        },
        "url": "URL#4117877"
    },
    {
        "@score": "1",
        "@id": "4117878",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "90/7258",
                        "text": "Yazan Boshmaf"
                    },
                    {
                        "@pid": "75/2905",
                        "text": "Dionysios Logothetis"
                    },
                    {
                        "@pid": "41/5119",
                        "text": "Georgos Siganos"
                    },
                    {
                        "@pid": "161/0511",
                        "text": "Jorge Ler\u00eda"
                    },
                    {
                        "@pid": "78/9244",
                        "text": "Jos\u00e9 Lorenzo"
                    },
                    {
                        "@pid": "93/24",
                        "text": "Matei Ripeanu"
                    },
                    {
                        "@pid": "47/6517",
                        "text": "Konstantin Beznosov"
                    }
                ]
            },
            "title": "Integro: Leveraging Victim Prediction for Robust Fake Account Detection in OSNs.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/BoshmafLSLLRB15",
            "ee": "https://www.ndss-symposium.org/ndss2015/integro-leveraging-victim-prediction-robust-fake-account-detection-osns",
            "url": "https://dblp.org/rec/conf/ndss/BoshmafLSLLRB15",
            "abstract": "Detecting fake accounts in online social networks (OSNs) protects OSN operators and their users from various malicious activities. Most detection mechanisms attempt to predict and classify user accounts as real (i.e., benign, honest) or fake (i.e., malicious, Sybil) by analyzing user-level activities or graph-level structures. These mechanisms, however, are not robust against adversarial attacks in which fake accounts cloak their operation with patterns resembling real user behavior. We herein demonstrate that victims, benign users who control real accounts and have befriended fakes, form a distinct classification category that is useful for designing robust detection mechanisms. First, as attackers have no control over victim accounts and cannot alter their activities, a victim account classifier which relies on user-level activities is relatively harder to circumvent. Second, as fakes are directly connected to victims, a fake account detection mechanism that integrates victim prediction into graphlevel structures is more robust against manipulations of the graph. To validate this new approach, we designed Integro, a scalable defense system that helps OSNs detect fake accounts using a meaningful a user ranking scheme. Integro starts by predicting victim accounts from user-level activities. After that, it integrates these predictions into the graph as weights, so that edges incident to predicted victims have much lower weights than others. Finally, Integro ranks user accounts based on a modified random walk that starts from a known real account. Integro guarantees that most real accounts rank higher than fakes so that OSN operators can take actions against low-ranking fake accounts. We implemented Integro using widely-used, open-source distributed computing platforms in which it scaled nearly linearly. We evaluated Integro against SybilRank, the state-of-the-art in fake account detection, using real-world datasets and a largescale deployment at Tuenti, the largest OSN in Spain. We show that Integro significantly outperforms SybilRank in user ranking quality, where the only requirement is to employ a victim classifier is better than random. Moreover, the deployment of Integro at Tuenti resulted in up to an order of magnitude higher precision in fake accounts detection, as compared to SybilRank.",
            "keywords": [
                "Fake Account Detection",
                "Online Social Networks",
                "Victim Prediction",
                "Graph-based Detection",
                "Sybil Attacks"
            ]
        },
        "url": "URL#4117878",
        "sema_paperId": "619975561d9aeff89ba57402385d6ebe229bf30e"
    },
    {
        "@score": "1",
        "@id": "4117879",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "146/7946",
                        "text": "Raphael Bost"
                    },
                    {
                        "@pid": "91/275",
                        "text": "Raluca Ada Popa"
                    },
                    {
                        "@pid": "09/8165",
                        "text": "Stephen Tu"
                    },
                    {
                        "@pid": "g/ShafiGoldwasser",
                        "text": "Shafi Goldwasser"
                    }
                ]
            },
            "title": "Machine Learning Classification over Encrypted Data.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/BostPTG15",
            "ee": "https://www.ndss-symposium.org/ndss2015/machine-learning-classification-over-encrypted-data",
            "url": "https://dblp.org/rec/conf/ndss/BostPTG15",
            "abstract": "Machine learning classification is used in numerous settings nowadays, such as medical or genomics predictions, spam detection, face recognition, and financial predictions. Due to privacy concerns, in some of these applications, it is important that the data and the classifier remain confidential. In this work, we construct three major classification protocols that satisfy this privacy constraint: hyperplane decision, Naive Bayes, and decision trees. We also enable these protocols to be combined with AdaBoost. At the basis of these constructions is a new library of building blocks for constructing classifiers securely; we demonstrate that this library can be used to construct other classifiers as well, such as a multiplexer and a face detection classifier. We implemented and evaluated our library and classifiers. Our protocols are efficient, taking milliseconds to a few seconds to perform a classification when running on real medical datasets.",
            "pdf_url": "https://www.ndss-symposium.org/wp-content/uploads/2017/09/04_1_2.pdf",
            "keywords": [
                "Encrypted Data Classification",
                "Privacy-preserving Machine Learning",
                "Secure Classifiers",
                "Medical Data Privacy",
                "AdaBoost Integration"
            ]
        },
        "url": "URL#4117879"
    },
    {
        "@score": "1",
        "@id": "4117880",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "28/8733",
                        "text": "Yinzhi Cao"
                    },
                    {
                        "@pid": "11/10929",
                        "text": "Yanick Fratantonio"
                    },
                    {
                        "@pid": "99/3883",
                        "text": "Antonio Bianchi"
                    },
                    {
                        "@pid": "27/3108",
                        "text": "Manuel Egele"
                    },
                    {
                        "@pid": "k/ChristopherKruegel",
                        "text": "Christopher Kruegel"
                    },
                    {
                        "@pid": "v/GiovanniVigna",
                        "text": "Giovanni Vigna"
                    },
                    {
                        "@pid": "88/2827-4",
                        "text": "Yan Chen 0004"
                    }
                ]
            },
            "title": "EdgeMiner: Automatically Detecting Implicit Control Flow Transitions through the Android Framework.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/CaoFBEKVC15",
            "ee": "https://www.ndss-symposium.org/ndss2015/edgeminer-automatically-detecting-implicit-control-flow-transitions-through-android-framework",
            "url": "https://dblp.org/rec/conf/ndss/CaoFBEKVC15",
            "abstract": "Android users can choose from over one million applications (apps) offered through the official Google Play marketplace. Furthermore, a wealth of alternative sources for Android applications is available for users to choose from. These range from curated stores, such as Amazon\u2019s Appstore to less legitimate sources that offer pirated content. The sheer number of mobile applications prompted researchers from academia and industry to develop static analysis techniques that scrutinize these applications for vulnerabilities and malicious functionality. Android applications always execute in the context of the Android framework \u2014 a comprehensive collection of functionality that developers can conveniently use from their applications. The prolific use of the framework poses unique challenges for the analysis of Android applications.",
            "keywords": [
                "Android Framework Analysis",
                "Static Analysis",
                "Vulnerability Detection",
                "Malicious Functionality",
                "Control Flow Transitions"
            ]
        },
        "url": "URL#4117880",
        "sema_paperId": "7b566c1393eb34fc1fdd6673aab84a022095eda6"
    },
    {
        "@score": "1",
        "@id": "4117881",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "16/3283-38",
                        "text": "Xi Chen 0038"
                    },
                    {
                        "@pid": "55/6285",
                        "text": "Asia Slowinska"
                    },
                    {
                        "@pid": "131/5092",
                        "text": "Dennis Andriesse"
                    },
                    {
                        "@pid": "91/800",
                        "text": "Herbert Bos"
                    },
                    {
                        "@pid": "75/8194",
                        "text": "Cristiano Giuffrida"
                    }
                ]
            },
            "title": "StackArmor: Comprehensive Protection From Stack-based Memory Error Vulnerabilities for Binaries.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/ChenSABG15",
            "ee": "https://www.ndss-symposium.org/ndss2015/stackarmor-comprehensive-protection-stack-based-memory-error-vulnerabilities-binaries",
            "url": "https://dblp.org/rec/conf/ndss/ChenSABG15",
            "abstract": "StackArmor is a comprehensive protection technique for stack-based memory error vulnerabilities in binaries. It relies on binary analysis and rewriting strategies to drastically reduce the uniquely high spatial and temporal memory predictability of traditional call stack organizations. Unlike prior solutions, StackArmor can protect against arbitrary stack-based attacks, requires no access to the source code, and offers a policy-driven protection strategy that allows end users to tune the securityperformance tradeoff according to their needs. We present an implementation of StackArmor for x86 64 Linux and provide a detailed experimental analysis of our prototype on popular server programs and standard benchmarks (SPEC CPU2006). Our results demonstrate that StackArmor offers better security than prior binaryand source-level approaches, at the cost of only modest performance and memory overhead even with full protection.",
            "keywords": [
                "Binary Analysis",
                "Memory Error Vulnerabilities",
                "Stack-based Attacks",
                "Policy-driven Protection",
                "Performance Overhead"
            ]
        },
        "url": "URL#4117881",
        "sema_paperId": "d4914de7dbb5080d5c83004cab22df9100fb37d0"
    },
    {
        "@score": "1",
        "@id": "4117882",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "05/2746",
                        "text": "Stephen Crane"
                    },
                    {
                        "@pid": "78/10907",
                        "text": "Andrei Homescu"
                    },
                    {
                        "@pid": "10/7583-1",
                        "text": "Stefan Brunthaler 0001"
                    },
                    {
                        "@pid": "12/4238",
                        "text": "Per Larsen"
                    },
                    {
                        "@pid": "f/MichaelFranz",
                        "text": "Michael Franz"
                    }
                ]
            },
            "title": "Thwarting Cache Side-Channel Attacks Through Dynamic Software Diversity.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/CraneHBLF15",
            "ee": "https://www.ndss-symposium.org/ndss2015/thwarting-cache-side-channel-attacks-through-dynamic-software-diversity",
            "url": "https://dblp.org/rec/conf/ndss/CraneHBLF15",
            "abstract": "We explore software diversity as a defense against side-channel attacks by dynamically and systematically random- izing the control flow of programs. Existing software diversity techniques transform each program trace identically. Our di- versity based technique instead transforms programs to make each program trace unique. This approach offers probabilistic protection against both online and off-line side-channel attacks. In particular, we create a large number of unique program execution paths by automatically generating diversified replicas for parts of an input program. Replicas derived from the same original program fragment have different implementations, but perform semantically equivalent computations. At runtime we then randomly and frequently switch between these replicas. We evaluate how well our approach thwarts cache-based side- channel attacks, in which an attacker strives to recover cryp- tographic keys by analyzing side-effects of program execution. Our method requires no manual effort or hardware changes, has a reasonable performance impact, and reduces side-channel information leakage significantly.",
            "keywords": [
                "Software Diversity",
                "Side-Channel Attacks",
                "Cache Attacks",
                "Dynamic Control Flow",
                "Cryptographic Key Recovery"
            ]
        },
        "url": "URL#4117882",
        "sema_paperId": "0183d8c6623aaf106a27db72ecec9bb9704ab98c"
    },
    {
        "@score": "1",
        "@id": "4117883",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "73/7564",
                        "text": "Lucas Davi"
                    },
                    {
                        "@pid": "131/5096",
                        "text": "Christopher Liebchen"
                    },
                    {
                        "@pid": "s/AhmadRezaSadeghi",
                        "text": "Ahmad-Reza Sadeghi"
                    },
                    {
                        "@pid": "29/8732",
                        "text": "Kevin Z. Snow"
                    },
                    {
                        "@pid": "50/6700",
                        "text": "Fabian Monrose"
                    }
                ]
            },
            "title": "Isomeron: Code Randomization Resilient to (Just-In-Time) Return-Oriented Programming.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/DaviLSSM15",
            "ee": "https://www.ndss-symposium.org/ndss2015/isomeron-code-randomization-resilient-just-time-return-oriented-programming",
            "url": "https://dblp.org/rec/conf/ndss/DaviLSSM15",
            "abstract": "Until recently, it was widely believed that code randomization (such as fine-grained ASLR) can effectively mitigate code reuse attacks. However, a recent attack strategy, dubbed just-in-time return oriented programming (JIT-ROP), circumvents code randomization by disclosing the (randomized) content of many memory pages at runtime. In order to remedy this situation, new and improved code randomization defenses have been proposed. \n \nThe contribution of this paper is twofold: first, we conduct a security analysis of a recently proposed fine-grained ASLR scheme that aims at mitigating JIT-ROP based on hiding direct code references in branch instructions. In particular, we demonstrate its weaknesses by constructing a novel JIT-ROP attack that is solely based on exploiting code references residing on the stack and heap. Our attack stresses that designing code randomization schemes resilient to memory disclosure is highly challenging. Second, we present a new and hybrid defense approach, dubbed Isomeron, that combines code randomization with execution-path randomization to mitigate conventional ROP and JIT-ROP attacks. Our reference implementation of Isomeron neither requires source code nor a static analysis phase. \nWe evaluated its efficiency based on SPEC benchmarks and discuss its effectiveness against various kinds of code reuse attacks.",
            "keywords": [
                "Code Randomization",
                "Just-In-Time Return-Oriented Programming",
                "Fine-Grained ASLR",
                "Memory Disclosure",
                "Isomeron Defense"
            ]
        },
        "url": "URL#4117883",
        "sema_paperId": "66f81b9b144ff0ce70945285e425571b9902b8cf"
    },
    {
        "@score": "1",
        "@id": "4117884",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "136/8374",
                        "text": "Soteris Demetriou"
                    },
                    {
                        "@pid": "77/6982",
                        "text": "Xiao-yong Zhou"
                    },
                    {
                        "@pid": "120/9715-1",
                        "text": "Muhammad Naveed 0001"
                    },
                    {
                        "@pid": "153/5787",
                        "text": "Yeonjoon Lee"
                    },
                    {
                        "@pid": "03/7768",
                        "text": "Kan Yuan"
                    },
                    {
                        "@pid": "06/6268",
                        "text": "XiaoFeng Wang 0001"
                    },
                    {
                        "@pid": "g/CarlAGunter",
                        "text": "Carl A. Gunter"
                    }
                ]
            },
            "title": "What&apos;s in Your Dongle and Bank Account? Mandatory and Discretionary Protection of Android External Resources.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/DemetriouZNLYWG15",
            "ee": "https://www.ndss-symposium.org/ndss2015/whats-your-dongle-and-bank-account-mandatory-and-discretionary-protection-android-external",
            "url": "https://dblp.org/rec/conf/ndss/DemetriouZNLYWG15",
            "abstract": "To address this challenge, we present in this paper SEACAT, a new security system for fine-grained, flexible protection on external resources. SEACAT supports both MAC and DAC, and integrates their enforcement mechanisms across the Android middleware and the Linux kernel. It extends SEAndroid for specifying policies on external resources, and also hosts a DAC policy base. Both sets of policies are managed under the same policy engine and Access Vector Cache that support policy checks within the security hooks distributed across the framework and the Linux kernel layers, over different channels. This integrated security model was carefully designed to ensure that misconfigured DAC policies will not affect the enforcement of MAC policies, which manufacturers and system administrators can leverage to define their security rules. In the meantime, a policy management service is offered to the ordinary Android users for setting policies that protect the resources provided by the third party. This service translates simple user selections into SELinux-compatible policies in the background. Our implementation is capable of thwarting all known attacks on external resources at a negligible performance cost.",
            "keywords": [
                "Android Security",
                "External Resource Protection",
                "Mandatory Access Control (MAC)",
                "Discretionary Access Control (DAC)",
                "Policy Management"
            ]
        },
        "url": "URL#4117884",
        "sema_paperId": "4001632141ad34211a097cfcfc03cae644f1be45"
    },
    {
        "@score": "1",
        "@id": "4117885",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "148/1556",
                        "text": "Daniel Demmler"
                    },
                    {
                        "@pid": "06/3872-3",
                        "text": "Thomas Schneider 0003"
                    },
                    {
                        "@pid": "73/11043",
                        "text": "Michael Zohner"
                    }
                ]
            },
            "title": "ABY - A Framework for Efficient Mixed-Protocol Secure Two-Party Computation.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/Demmler0Z15",
            "ee": "https://www.ndss-symposium.org/ndss2015/aby---framework-efficient-mixed-protocol-secure-two-party-computation",
            "url": "https://dblp.org/rec/conf/ndss/Demmler0Z15",
            "abstract": "from details of underlying secure computation protocol Use only fast symmetric key crypto Code is available on GitHub: http://encrypto.de/code/ABY",
            "keywords": [
                "Secure Two-Party Computation",
                "Mixed-Protocol Framework",
                "Symmetric Key Cryptography",
                "Efficient Computation",
                "ABY Framework"
            ]
        },
        "url": "URL#4117885",
        "sema_paperId": "20b5b5c25e2b56693b38fe7f69caddca78872085"
    },
    {
        "@score": "1",
        "@id": "4117886",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "09/4218",
                        "text": "Mohan Dhawan"
                    },
                    {
                        "@pid": "39/10311",
                        "text": "Rishabh Poddar"
                    },
                    {
                        "@pid": "161/0737",
                        "text": "Kshiteej Mahajan"
                    },
                    {
                        "@pid": "06/2290",
                        "text": "Vijay Mann"
                    }
                ]
            },
            "title": "SPHINX: Detecting Security Attacks in Software-Defined Networks.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/DhawanPMM15",
            "ee": "https://www.ndss-symposium.org/ndss2015/sphinx-detecting-security-attacks-software-defined-networks",
            "url": "https://dblp.org/rec/conf/ndss/DhawanPMM15",
            "abstract": "Software-defined networks (SDNs) allow greater control over network entities by centralizing the control plane, but place great burden on the administrator to manually ensure security and correct functioning of the entire network. We list several attacks on SDN controllers that violate network topology and data plane forwarding, and can be mounted by compromised network entities, such as end hosts and soft switches. We further demonstrate their feasibility on four popular SDN controllers. We propose SPHINX to detect both known and potentially unknown attacks on network topology and data plane forwarding originating within an SDN. SPHINX leverages the novel abstraction of flow graphs, which closely approximate the actual network operations, to enable incremental validation of all network updates and constraints. SPHINX dynamically learns new network behavior and raises alerts when it detects suspicious changes to existing network control plane behavior. Our evaluation shows that SPHINX is capable of detecting attacks in SDNs in realtime with low performance overheads, and requires no changes to the controllers for deployment.",
            "keywords": [
                "Software-Defined Networks",
                "Network Security",
                "SDN Controller Attacks",
                "Flow Graphs",
                "Real-time Attack Detection"
            ]
        },
        "url": "URL#4117886",
        "sema_paperId": "271a00f8bb8674e66f7ec1005a0e6dc2f41dd4e0"
    },
    {
        "@score": "1",
        "@id": "4117887",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "117/8994",
                        "text": "Simon Eberz"
                    },
                    {
                        "@pid": "01/4779",
                        "text": "Kasper Bonne Rasmussen"
                    },
                    {
                        "@pid": "75/5939",
                        "text": "Vincent Lenders"
                    },
                    {
                        "@pid": "87/2623",
                        "text": "Ivan Martinovic"
                    }
                ]
            },
            "title": "Preventing Lunchtime Attacks: Fighting Insider Threats With Eye Movement Biometrics.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/EberzRLM15",
            "ee": "https://www.ndss-symposium.org/ndss2015/preventing-lunchtime-attacks-fighting-insider-threats-eye-movement-biometrics",
            "url": "https://dblp.org/rec/conf/ndss/EberzRLM15",
            "abstract": "We introduce a novel biometric based on distinctive eye movement patterns. The biometric consists of 21 features that allow us to reliably distinguish users based on differences in these patterns. We leverage this distinguishing power along with the ability to gauge the users' task familiarity, i.e., level of knowledge, to address insider threats. In a controlled experiment we test how both time and task familiarity influence eye movements and feature stability, and how different subsets of features affect the classifier performance. These feature subsets can be used to tailor the eye movement biometric to different authentication methods and threat models. Our results show that eye movement biometrics support reliable and stable identification and authen- tication of users. We investigate different approaches in which an attacker could attempt to use inside knowledge to mimic the legitimate user. Our results show that while this advance knowledge is measurable, it does not increase the likelihood of successful impersonation. In order to determine the time stability of our features we repeat the experiment twice within two weeks. The results indicate that we can reliably authenticate users over the entire period. We show that the classification decision depends on all features and mimicking a few of them will not be sufficient to trick the classifier. We discuss the advantages and limitations of our approach in detail and give practical insights on the use of this biometric in a real-world environment. I. INTRODUCTION In this paper, we evaluate the effectiveness of using eye movement biometrics as a novel defence against the \"lunchtime attack\" by an insider threat. An insider threat in this context refers to a person with physical access to a workstation that he is not supposed to use (e.g., using a coworker's workstation while he is at lunch). As such our system serves as a second line of defense after the workstation has already been compromised (i.e., the attacker has physical access and the workstation is either unlocked or he is in possession of all necessary passwords and access tokens). Our approach considers both users that are simply careless and users that are actively collaborating with the attacker by giving up information. The second case makes this attack notoriously difficult to defend against. We propose a set of features that can be extracted from human eye movements and analyze their distinctiveness and robustness using a systematic experimental design. The human eyes offer a rich feature space based on volun- tary, involuntary, and reflexive eye movements. Traditionally, the analysis of eye movements has been used in the medical domain to facilitate diagnosis of different ocular and neuronal disorders. Eye tracking devices have become much cheaper within the last years and even low-cost open-source hardware and software is available (1). Recent advances in video-based eye tracking technology makes eye tracking applicable to a conventional workplace as it does not require any physical contact with the users (more detail on eye tracking is given in Section II). Our experimental design captures the unique characteristics of each user's eye movements as measured by the eye tracker. We also consider ways in which the attacker could use his position to gain inside information about the user and the system through observation or social engineering. We define metrics to measure this advance knowledge through eye movement data and determine whether it affects the authentication decision. We consider three scenarios in particular: (i) no prior knowledge, i.e., no information advantage; (ii) knowledge gained through a description, e.g., the adversary is provided with a textual description by a colluding legitimate user; and (iii) knowledge gain through observation, e.g., by looking over the shoulder of a legitimate user performing a task (shoulder-surfing). We perform these experiments with 30 subjects recruited from the general public and repeat them after two weeks to test the time-stability of the proposed features. While our experimental results show that an adversary does benefit from an increased level of knowledge when executing a task, the analysis of the proposed features also shows that he cannot utilize that knowledge to circumvent the eye movement biometric. Our main contributions are a set of 21 features and measurements that confirm that these features are suitable to perform user authentication. We carefully consider various error sources and validate our design by looking at the learning behavior of our test subjects. We further show that it is possible to gauge the level of familiarity with a specific task through the eye tracker biometric. This property is very useful when dealing with an insider threat. Finally we also present a basic authentication system based on this biometric as well as a discussion of the robustness of our results over time.",
            "keywords": [
                "Eye Movement Biometrics",
                "Insider Threats",
                "User Authentication",
                "Lunchtime Attacks",
                "Task Familiarity"
            ]
        },
        "url": "URL#4117887",
        "sema_paperId": "68466559fe03aee2214bc00842209861bb2052fe"
    },
    {
        "@score": "1",
        "@id": "4117888",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "37/7954",
                        "text": "Birhanu Eshete"
                    },
                    {
                        "@pid": "161/0736",
                        "text": "Abeer Alhuzali"
                    },
                    {
                        "@pid": "134/5499",
                        "text": "Maliheh Monshizadeh"
                    },
                    {
                        "@pid": "48/3729",
                        "text": "Phillip A. Porras"
                    },
                    {
                        "@pid": "90/5014",
                        "text": "Venkat N. Venkatakrishnan"
                    },
                    {
                        "@pid": "75/3570",
                        "text": "Vinod Yegneswaran"
                    }
                ]
            },
            "title": "EKHunter: A Counter-Offensive Toolkit for Exploit Kit Infiltration.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/EsheteAMPVY15",
            "ee": "https://www.ndss-symposium.org/ndss2015/ekhunter-counter-offensive-toolkit-exploit-kit-infiltration",
            "url": "https://dblp.org/rec/conf/ndss/EsheteAMPVY15",
            "abstract": "The emergence of exploit kits is one of the most important developments in modern cybercrime. Much of cybersecurity research in the recent years has been devoted towards defending citizens from harm delivered through exploit kits. In this paper, we examine an alternate, counter-offensive strategy towards combating cybercrime launched through exploit kits. Towards this goal, we survey a wide range of 30 real-world exploit kits and analyze a counter-offensive adversarial model against the kits and kit operator. Guided by our analysis, we present a systematic methodology for examining a given kit to determine where vulnerabilities may reside within its serverside implementation. In our experiments, we found over 180 vulnerabilities among 16 exploit kits of those surveyed, and were able to automatically synthesize exploits for infiltrating 6 of them. The results validate our hypothesis that exploit kits largely lack sophistication necessary to resist counter-offensive activities. We then propose the design of EKHUNTER, a system that is capable of automatically detecting the presence of exploit vulnerabilities and deriving laboratory test cases that can compromise both the integrity of a fielded exploit kit, and even the identity of the kit operator. Keywords\u2014 exploit kits, web malware, offensive technologies, cybercrime.",
            "keywords": [
                "Exploit Kits",
                "Cybercrime",
                "Counter-Offensive Strategy",
                "Vulnerability Analysis",
                "EKHUNTER"
            ]
        },
        "url": "URL#4117888",
        "sema_paperId": "2f381011fe1a372c2987a335527250ff2f377ff6"
    },
    {
        "@score": "1",
        "@id": "4117889",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "87/2320",
                        "text": "Sharon Goldberg"
                    },
                    {
                        "@pid": "n/MoniNaor",
                        "text": "Moni Naor"
                    },
                    {
                        "@pid": "18/9002",
                        "text": "Dimitrios Papadopoulos 0001"
                    },
                    {
                        "@pid": "r/LeonidReyzin",
                        "text": "Leonid Reyzin"
                    },
                    {
                        "@pid": "88/11139",
                        "text": "Sachin Vasant"
                    },
                    {
                        "@pid": "150/0037",
                        "text": "Asaf Ziv"
                    }
                ]
            },
            "title": "NSEC5: Provably Preventing DNSSEC Zone Enumeration.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/GoldbergNPRVZ15",
            "ee": "https://www.ndss-symposium.org/ndss2015/nsec5-provably-preventing-dnssec-zone-enumeration",
            "url": "https://dblp.org/rec/conf/ndss/GoldbergNPRVZ15",
            "abstract": "This paper uses cryptographic techniques to study the problem of zone enumeration in DNSSEC. DNSSEC is designed to prevent network attackers from tampering with domain name system (DNS) messages. The cryptographic machinery used in DNSSEC, however, also creates a new vulnerability, zone enumeration, enabling an adversary to use a small number of online DNSSEC queries combined with offline dictionary attacks to learn which domain names are present or absent in a DNS zone. We prove that the design underlying current DNSSEC standard, with NSEC and NSEC3 records, inherently suffers from zone enumeration: specifically, we show that security against network attackers and privacy against zone enumeration cannot be satisfied simultaneously unless the DNSSEC server performs online public-key cryptographic operations. We then propose NSEC5, a new cryptographic construction that solves the problem of DNSSEC zone enumeration while remaining faithful to the operational realities of DNSSEC. NSEC5 can be thought of as a variant of NSEC3 in which an the unkeyed hash function is replaced with an RSA-based keyed hashing scheme.",
            "pdf_url": "https://www.ndss-symposium.org/wp-content/uploads/2017/09/06_5_0.pdf",
            "keywords": [
                "DNSSEC",
                "Zone Enumeration",
                "Cryptographic Techniques",
                "NSEC5",
                "Privacy Vulnerability"
            ]
        },
        "url": "URL#4117889"
    },
    {
        "@score": "1",
        "@id": "4117890",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "69/4456",
                        "text": "Michael I. Gordon"
                    },
                    {
                        "@pid": "35/9698",
                        "text": "Deokhwan Kim"
                    },
                    {
                        "@pid": "24/972",
                        "text": "Jeff H. Perkins"
                    },
                    {
                        "@pid": "84/2220",
                        "text": "Limei Gilham"
                    },
                    {
                        "@pid": "38/6441-2",
                        "text": "Nguyen Nguyen 0002"
                    },
                    {
                        "@pid": "r/MartinCRinard",
                        "text": "Martin C. Rinard"
                    }
                ]
            },
            "title": "Information Flow Analysis of Android Applications in DroidSafe.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/GordonKPGNR15",
            "ee": "https://www.ndss-symposium.org/ndss2015/information-flow-analysis-android-applications-droidsafe",
            "url": "https://dblp.org/rec/conf/ndss/GordonKPGNR15",
            "abstract": "We present DroidSafe, a static information flow analysis tool that reports potential leaks of sensitive information in Android applications. DroidSafe combines a comprehensive, accurate, and precise model of the Android runtime with static analysis design decisions that enable the DroidSafe analyses to scale to analyze this model. This combination is enabled by accurate analysis stubs, a technique that enables the effective analysis of code whose complete semantics lies outside the scope of Java, and by a combination of analyses that together can statically resolve communication targets identified by dynamically constructed values such as strings and class designators. Our experimental results demonstrate that 1) DroidSafe achieves unprecedented precision and accuracy for Android information flow analysis (as measured on a standard previously published set of benchmark applications) and 2) DroidSafe detects all malicious information flow leaks inserted into 24 real-world Android applications by three independent, hostile Red-Team organizations. The previous state-of-the art analysis, in contrast, detects less than 10% of these malicious flows.",
            "keywords": [
                "Android Applications",
                "Static Information Flow Analysis",
                "Information Leak Detection",
                "DroidSafe",
                "Malicious Information Flow"
            ]
        },
        "url": "URL#4117890",
        "sema_paperId": "5aec33d09e7d8fcee795c2ce6b70cab89665c519"
    },
    {
        "@score": "1",
        "@id": "4117891",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "84/8930",
                        "text": "Benjamin G\u00fcldenring"
                    },
                    {
                        "@pid": "23/1185-2",
                        "text": "Volker Roth 0002"
                    },
                    {
                        "@pid": "125/2004",
                        "text": "Lars Ries"
                    }
                ]
            },
            "title": "Knock Yourself Out: Secure Authentication with Short Re-Usable Passwords.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/GuldenringRR15",
            "ee": "https://www.ndss-symposium.org/ndss2015/knock-yourself-out-secure-authentication-short-re-usable-passwords",
            "url": "https://dblp.org/rec/conf/ndss/GuldenringRR15",
            "abstract": "\u2014We present Knock Yourself Out (KYO), a password generator that enables secure authentication against a computationally unbounded adversary. Master passwords can be surprisingly short and may be re-used for multiple service accounts even in the event of client compromises and multiple server compromises. At the same time, KYO is transparent to service operators and backwards-compatible. Master passwords are fully client-manageable while secrets shared with service operators can be kept constant. Likewise, secrets can be changed without having to change one's passwords. KYO does not rely on collision-resistant hash functions and can be implemented with fast non-cryptographic hash functions. We detail the design of KYO and we analyze its security mathematically in a random hash function model. In our empirical evaluation we find that KYO remains secure even if small sets of hash functions are used instead, in other words, KYO requires minimal storage and is highly practical.",
            "keywords": [
                "Password Generation",
                "Secure Authentication",
                "Master Passwords",
                "Client-Managed Secrets",
                "Non-Collision Hash Functions"
            ]
        },
        "url": "URL#4117891",
        "sema_paperId": "5ef7096c9ff339881b327edba85873d967d113a2"
    },
    {
        "@score": "1",
        "@id": "4117892",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "26/7361",
                        "text": "Payas Gupta"
                    },
                    {
                        "@pid": "185/6256",
                        "text": "Bharat Srinivasan"
                    },
                    {
                        "@pid": "87/7127",
                        "text": "Vijay Balasubramaniyan"
                    },
                    {
                        "@pid": "73/3162",
                        "text": "Mustaque Ahamad"
                    }
                ]
            },
            "title": "Phoneypot: Data-driven Understanding of Telephony Threats.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/GuptaSBA15",
            "ee": "https://www.ndss-symposium.org/ndss2015/phoneypot-data-driven-understanding-telephony-threats",
            "url": "https://dblp.org/rec/conf/ndss/GuptaSBA15",
            "abstract": "Cyber criminals are increasingly using robocalling, voice phishing and caller ID spoofing to craft attacks that are being used to scam unsuspecting users who have traditionally trusted the telephone. It is necessary to better understand telephony threats to effectively combat them. Although there exist crowd sourced complaint datasets about telephony abuse, such complaints are often filed after a user receives multiple calls over a period of time, and sometimes they lack important information. We believe honeypot technologies can be used to augment telephony abuse intelligence and improve its quality. However, a telephony honeypot presents several new challenges that do not arise in other traditional honeypot settings. We present Phoneypot, a first large scale telephony honeypot, that allowed us to explore ways to address these challenges. By presenting a concrete implementation of Phoneypot using a cloud infrastructure and 39,696 phone numbers (phoneytokens), we provide evidence of the benefits of telephony honeypots. Phoneypot received 1.3 million calls from 250K unique sources over a period of seven weeks. We detected several debt collectors and telemarketers calling patterns and an instance of a telephony denial-of-service attack. This provides us with new insights into telephony abuse and attack patterns.",
            "keywords": [
                "Telephony Threats",
                "Robocalling",
                "Voice Phishing",
                "Caller ID Spoofing",
                "Telephony Honeypot"
            ]
        },
        "url": "URL#4117892",
        "sema_paperId": "e64fa23b2a1971d658e5d3b5bdf62063ec1f7317"
    },
    {
        "@score": "1",
        "@id": "4117893",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "77/7581",
                        "text": "Sungmin Hong"
                    },
                    {
                        "@pid": "19/360-24",
                        "text": "Lei Xu 0024"
                    },
                    {
                        "@pid": "129/7094",
                        "text": "Haopei Wang"
                    },
                    {
                        "@pid": "64/1147",
                        "text": "Guofei Gu"
                    }
                ]
            },
            "title": "Poisoning Network Visibility in Software-Defined Networks: New Attacks and Countermeasures.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/HongXWG15",
            "ee": "https://www.ndss-symposium.org/ndss2015/poisoning-network-visibility-software-defined-networks-new-attacks-and-countermeasures",
            "url": "https://dblp.org/rec/conf/ndss/HongXWG15",
            "abstract": "Software-Defined Networking (SDN) is a new networking paradigm that grants a controller and its applications an omnipotent power to have holistic network visibility and flexible network programmability, thus enabling new innovations in network protocols and applications. One of the core advantages of SDN is its logically centralized control plane to provide the entire network visibility, on which many SDN applications rely. For the first time in the literature, we propose new attack vectors unique to SDN that seriously challenge this foundation. Our new attacks are somewhat similar in spirit to spoofing attacks in legacy networks (e.g., ARP poisoning attack), however with significant differences in exploiting unique vulnerabilities how current SDN operates differently from legacy networks. The successful attacks can effectively poison the network topology information, a fundamental building block for core SDN components and topology-aware SDN applications. With the poisoned network visibility, the upper-layer OpenFlow controller services/apps may be totally misled, leading to serious hijacking, denial of service or man-in-the-middle attacks. According to our study, all current major SDN controllers we find in the market (e.g., Floodlight, OpenDaylight, Beacon, and POX) are affected, i.e., they are subject to the Network Topology Poisoning Attacks. We then investigate the mitigation methods against the Network Topology Poisoning Attacks and present TopoGuard, a new security extension to SDN controllers, which provides automatic and real-time detection of Network Topology Poisoning Attacks. Our evaluation on a prototype implementation of TopoGuard in the Floodlight controller shows that the defense solution can effectively secure network topology while introducing only a minor impact on normal operations of OpenFlow controllers.",
            "keywords": [
                "Software-Defined Networking",
                "Network Topology",
                "Poisoning Attacks",
                "SDN Controller Security",
                "TopoGuard"
            ]
        },
        "url": "URL#4117893",
        "sema_paperId": "d6d3d62900cc8b5c230e0e5aaa46f19672e9cab1"
    },
    {
        "@score": "1",
        "@id": "4117894",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "43/6896",
                        "text": "Jin Soo Jang"
                    },
                    {
                        "@pid": "161/0496",
                        "text": "Sunjune Kong"
                    },
                    {
                        "@pid": "25/6052",
                        "text": "Minsu Kim"
                    },
                    {
                        "@pid": "153/5774",
                        "text": "Daegyeong Kim"
                    },
                    {
                        "@pid": "17/6702",
                        "text": "Brent ByungHoon Kang"
                    }
                ]
            },
            "title": "SeCReT: Secure Channel between Rich Execution Environment and Trusted Execution Environment.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/JangKKKK15",
            "ee": "https://www.ndss-symposium.org/ndss2015/secret-secure-channel-between-rich-execution-environment-and-trusted-execution-environment",
            "url": "https://dblp.org/rec/conf/ndss/JangKKKK15",
            "abstract": "We propose SeCReT to ameliorate this problem. SeCReT is a framework that builds a secure channel between the REE and TEE by enabling REE processes to use session keys in the REE that is regarded as unsafe region. SeCReT provides the session key to a requestor process only when the requestor\u2019s code and control flow integrity are verified. To prevent the key from being exposed to an attacker who already compromised the REE kernel, SeCReT flushes the key from the memory every time the processor switches into kernel mode. In this paper, we present the design and implementation of SeCReT to show how it protects the key in the REE. Our prototype is implemented on Arndale board, which offers a Cortex-A15 dual-core processor with TrustZone as its security extension. We performed a security analysis by using a kernel rootkit and also ran LMBench microbenchmark to evaluate the performance overhead imposed by SeCReT.",
            "keywords": [
                "Secure Channel",
                "Rich Execution Environment",
                "Trusted Execution Environment",
                "Session Key Protection",
                "Control Flow Integrity"
            ]
        },
        "url": "URL#4117894",
        "sema_paperId": "3f4eef59703ff179e2faf08d04156d00acb1b352"
    },
    {
        "@score": "1",
        "@id": "4117895",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "07/8388",
                        "text": "Shouling Ji"
                    },
                    {
                        "@pid": "15/3702",
                        "text": "Weiqing Li"
                    },
                    {
                        "@pid": "03/9437",
                        "text": "Neil Zhenqiang Gong"
                    },
                    {
                        "@pid": "39/6266",
                        "text": "Prateek Mittal"
                    },
                    {
                        "@pid": "12/6354",
                        "text": "Raheem A. Beyah"
                    }
                ]
            },
            "title": "On Your Social Network De-anonymizablity: Quantification and Large Scale Evaluation with Seed Knowledge.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/JiLGMB15",
            "ee": "https://www.ndss-symposium.org/ndss2015/your-social-network-de-anonymizablity-quantification-and-large-scale-evaluation-seed-knowledge",
            "url": "https://dblp.org/rec/conf/ndss/JiLGMB15",
            "abstract": "In this paper, we conduct the first comprehensive quantification on the perfect de-anonymizability and partial deanonymizability of real world social networks with seed information in general scenarios, where a social network can follow an arbitrary distribution model. This quantification provides the theoretical foundation for existing structure based de-anonymization attacks (e.g., [1][2][3]) and closes the gap between de-anonymization practice and theory. Besides that, our quantification can serve as a testing-stone for the effectiveness of anonymization techniques, i.e., researchers can employ our quantified structural conditions to evaluate the potential deanonymizability of the anonymized social networks. Based on our quantification, we conduct a large scale evaluation on the de-anonymizability of 24 various real world social networks by quantitatively showing: 1) the conditions for perfect and (1\u2212 \u03b5) de-anonymization of a social network, where \u03b5 specifies the tolerated de-anonymization error, and 2) the number of users of a social network that can be successfully de-anonymized. Furthermore, we show that, both theoretically and experimentally, the overall structural information based de-anonymization attack is much more powerful than the seed knowledge-only based deanonymization attack, and even without any seed information, a social network can be perfectly or partially de-anonymized. Finally, we discuss the implications of this work. Our findings are expected to shed light on the future research in the structural data anonymization and de-anonymization area, and to help data owners evaluate their structural data vulnerability before data sharing and publishing.",
            "keywords": [
                "Social Network De-anonymization",
                "Data Anonymization",
                "Structural Information",
                "De-anonymizability Quantification",
                "Seed Knowledge"
            ]
        },
        "url": "URL#4117895",
        "sema_paperId": "e89d557ad41704841088ae7f8db9cb37ce5514f7"
    },
    {
        "@score": "1",
        "@id": "4117896",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "62/6079",
                        "text": "Brendan Juba"
                    },
                    {
                        "@pid": "149/2243",
                        "text": "Christopher Musco"
                    },
                    {
                        "@pid": "55/3921",
                        "text": "Fan Long"
                    },
                    {
                        "@pid": "37/1475",
                        "text": "Stelios Sidiroglou-Douskos"
                    },
                    {
                        "@pid": "r/MartinCRinard",
                        "text": "Martin C. Rinard"
                    }
                ]
            },
            "title": "Principled Sampling for Anomaly Detection.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/JubaMLSR15",
            "ee": "https://www.ndss-symposium.org/ndss2015/principled-sampling-anomaly-detection",
            "url": "https://dblp.org/rec/conf/ndss/JubaMLSR15",
            "abstract": "To address this issue we present a technique and implemented system, Fortuna, for obtaining probabilistic bounds on false positive rates for anomaly detectors that process Internet data. Using a probability distribution based on PageRank and an efficient algorithm to draw samples from the distribution, Fortuna computes an estimated false positive rate and a probabilistic bound on the estimate\u2019s accuracy. By drawing test samples from a well defined distribution that correlates well with data seen in practice, Fortuna improves on ad hoc methods for estimating false positive rate, giving bounds that are reproducible, comparable across different anomaly detectors, and theoretically sound. Experimental evaluations of three anomaly detectors (SIFT, SOAP, and JSAND) show that Fortuna is efficient enough to use in practice \u2014 it can sample enough inputs to obtain tight false positive rate bounds in less than 10 hours for all three detectors. These results indicate that Fortuna can, in practice, help place anomaly detection on a stronger theoretical foundation and help practitioners better understand the behavior and consequences of the anomaly detectors that they deploy. As part of our work, we obtain a theoretical result that may be of independent interest: We give a simple analysis of the convergence rate of the random surfer process defining PageRank that guarantees the same rate as the standard, second-eigenvalue analysis, but does not rely on any assumptions about the link structure of the web.",
            "keywords": [
                "Anomaly Detection",
                "Probabilistic Bounds",
                "False Positive Rate",
                "Sampling Techniques",
                "PageRank"
            ]
        },
        "url": "URL#4117896",
        "sema_paperId": "d0bd8091c0a3fd6112527299d4fb05aeeb290a8e"
    },
    {
        "@score": "1",
        "@id": "4117897",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "228/4998",
                        "text": "Michael J. Kranch"
                    },
                    {
                        "@pid": "27/3087",
                        "text": "Joseph Bonneau"
                    }
                ]
            },
            "title": "Upgrading HTTPS in mid-air: An empirical study of strict transport security and key pinning.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/KranchB15",
            "ee": "https://www.ndss-symposium.org/ndss2015/upgrading-https-mid-air-empirical-study-strict-transport-security-and-key-pinning",
            "url": "https://dblp.org/rec/conf/ndss/KranchB15",
            "abstract": "We have conducted the first in-depth empirical study of two important new web security features: strict transport security (HSTS) and public-key pinning. Both have been added to the web platform to harden HTTPS, the prevailing standard for secure web browsing. While HSTS is further along, both features still have very limited deployment at a few large websites and a long tail of small, security-conscious sites. We find evidence that many developers do not completely understand these features, with a substantial portion using them in invalid or illogical ways. The majority of sites we observed trying to set an HSTS header did so with basic errors that significantly undermine the security this feature is meant to provide. We also identify several subtle but important new pitfalls in deploying these features in practice. For example, the majority of pinned domains undermined the security benefits by loading non-pinned resources with the ability to hijack the page. A substantial portion of HSTS domains and nearly all pinned domains leaked cookie values, including login cookies, due to the poorly-understood interaction between HTTP cookies and the same-origin policy. Our findings highlight that the web platform, as well as modern web sites, are large and complicated enough to make even conceptually simple security upgrades challenging to deploy in practice.",
            "keywords": [
                "Web Security Features",
                "Strict Transport Security",
                "Public-Key Pinning",
                "HTTPS Deployment Issues",
                "Cookie Leakage"
            ]
        },
        "url": "URL#4117897",
        "sema_paperId": "7a78dbb8ceb0200add67dbe6479685bbde7e77ab"
    },
    {
        "@score": "1",
        "@id": "4117898",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "139/7034",
                        "text": "Yonghwi Kwon 0001"
                    },
                    {
                        "@pid": "34/5165",
                        "text": "Fei Peng"
                    },
                    {
                        "@pid": "126/4248",
                        "text": "Dohyeong Kim"
                    },
                    {
                        "@pid": "78/5052",
                        "text": "Kyungtae Kim"
                    },
                    {
                        "@pid": "95/3760-1",
                        "text": "Xiangyu Zhang 0001"
                    },
                    {
                        "@pid": "59/5539",
                        "text": "Dongyan Xu"
                    },
                    {
                        "@pid": "75/3570",
                        "text": "Vinod Yegneswaran"
                    },
                    {
                        "@pid": "161/0544",
                        "text": "John Qian"
                    }
                ]
            },
            "title": "P2C: Understanding Output Data Files via On-the-Fly Transformation from Producer to Consumer Executions.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/KwonPKKZXYQ15",
            "ee": "https://www.ndss-symposium.org/ndss2015/p2c-understanding-output-data-files-fly-transformation-producer-consumer-executions",
            "url": "https://dblp.org/rec/conf/ndss/KwonPKKZXYQ15",
            "abstract": "In cyber attack analysis, it is often highly desirable to understand the meaning of an unknown file or network message in the absence of their consumer (i.e. the program that parses and understands the file/message). For example, a malware may stealthily collect information from a victim machine, store them as a file and later send it to a remote server. P2C is a novel technique that can parse and understand unknown files and network messages. Given a file/message that was generated in the past without the presence of any monitoring techniques, and a set of potential producers of the file/message, P2C systematically explores the execution paths in the producers without requiring any inputs. In the mean time, it tries to transform a producer execution to a consumer execution that closely resembles the ideal consumer execution that can parse the given unknown file/message. In particular, when a write operation is encountered in the original execution, P2C performs the opposite read operation on the unknown file/message and patches the original execution with the loaded value. In order to handle correlations between data fields in the file/message, P2C follows a trial-and-error approach to look for the correct transformation until the file/message can be parsed and the meaning of their fields can be disclosed. Our experiments on a set of real world applications demonstrate P2C is highly effective.",
            "keywords": [
                "Cyber Attack Analysis",
                "File Parsing",
                "Unknown File Understanding",
                "Producer-Consumer Execution",
                "Data Transformation"
            ]
        },
        "url": "URL#4117898",
        "sema_paperId": "07c5875d3cbea8bb39c291fdf6070fc21491d137"
    },
    {
        "@score": "1",
        "@id": "4117899",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "45/7986",
                        "text": "Byoungyoung Lee"
                    },
                    {
                        "@pid": "69/6818",
                        "text": "Chengyu Song"
                    },
                    {
                        "@pid": "150/5222",
                        "text": "Yeongjin Jang"
                    },
                    {
                        "@pid": "08/7063",
                        "text": "Tielei Wang"
                    },
                    {
                        "@pid": "38/8882",
                        "text": "Taesoo Kim"
                    },
                    {
                        "@pid": "81/7428",
                        "text": "Long Lu"
                    },
                    {
                        "@pid": "29/5976",
                        "text": "Wenke Lee"
                    }
                ]
            },
            "title": "Preventing Use-after-free with Dangling Pointers Nullification.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/LeeSJWKLL15",
            "ee": "https://www.ndss-symposium.org/ndss2015/preventing-use-after-free-dangling-pointers-nullification",
            "url": "https://dblp.org/rec/conf/ndss/LeeSJWKLL15",
            "abstract": "Many system components and network applications are written in languages that are prone to memory corruption vulnerabilities. There have been countless cases where simple mistakes by developers resulted in memory corruption vulnerabilities and consequently security exploits. While there have been tremendous research efforts to mitigate these vulnerabilities, useafter-free still remains one of the most critical and popular attack vectors because existing proposals have not adequately addressed the challenging program analysis and runtime performance issues. In this paper we present DANGNULL, a system that detects temporal memory safety violations\u2014in particular, use-after-free and double-free\u2014during runtime. DANGNULL relies on the key observation that the root cause of these violations is that pointers are not nullified after the target object is freed. Based on this observation, DANGNULL automatically traces the object\u2019s relationships via pointers and automatically nullifies all pointers when the target object is freed. DANGNULL offers several benefits. First, DANGNULL addresses the root cause of temporal memory safety violations. It does not rely on the side effects of violations, which can vary and may be masked by attacks. Thus, DANGNULL is effective against even the most sophisticated exploitation techniques. Second, DANGNULL checks object relationship information using runtime object range analysis on pointers, and thus is able to keep track of pointer semantics more robustly even in complex and large scale software. Lastly, DANGNULL does not require numerous explicit sanity checks on memory accesses because it can detect a violation with implicit exception handling, and thus its detection capabilities only incur moderate performance overhead.",
            "keywords": [
                "Memory Safety",
                "Use-after-free",
                "Temporal Memory Safety Violations",
                "Pointer Nullification",
                "Runtime Object Range Analysis"
            ]
        },
        "url": "URL#4117899",
        "sema_paperId": "215174223b5fb63c2d2f732633ff7542b2fce5ad"
    },
    {
        "@score": "1",
        "@id": "4117900",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "145/2031",
                        "text": "Wilson Lian"
                    },
                    {
                        "@pid": "35/1061",
                        "text": "Hovav Shacham"
                    },
                    {
                        "@pid": "s/StefanSavage",
                        "text": "Stefan Savage"
                    }
                ]
            },
            "title": "Too LeJIT to Quit: Extending JIT Spraying to ARM.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/LianSS15",
            "ee": "https://www.ndss-symposium.org/ndss2015/too-lejit-quit-extending-jit-spraying-arm",
            "url": "https://dblp.org/rec/conf/ndss/LianSS15",
            "abstract": "In the face of widespread DEP and ASLR deploy- ment, JIT spraying brings together the best of code injection and code reuse attacks to defeat both defenses. However, to date, JIT spraying has been an x86-only attack thanks to its reliance on variable-length, unaligned instructions. In this paper, we finally extend JIT spraying to a RISC architecture by introducing a novel technique called gadget chaining, whereby high level code invokes short sequences of unintended and intended instructions called gadgets just like a function call. We demonstrate gadget chaining in an end-to-end JIT spraying attack against WebKit's JavaScriptCore JS engine on ARM and found that existing JIT spray mitigations that were sufficient against the x86 version of the JIT spraying attack fall short in the face of gadget chaining. I. INTRODUCTION It is no secret that programs are replete with bugs. Some of these bugs allow an attacker to subvert control of the program counter and divert execution away from its intended path; these are called control flow vulnerabilities. Unfortunately for a would-be attacker, a control flow vulnerability is not enough to execute arbitrary code on a remote machine. Defense mechanisms such as DEP and ASLR prevent attackers from writing code into a process's address space and decrease the likelihood that triggering a control flow vulnerability will cause an attacker's target code to execute. JIT spraying is an attack which defeats both DEP and ASLR by enabling an attacker to predictably influence large swaths of the victim process's executable memory. The attack exploits Just-in-Time compilers built into many recent lan- guage runtimes for the purpose of speeding up the performance of frequently-executed code, but it has only been demonstrated for the x86 architecture. More and more handheld devices, which are predominantly powered by ARM processors, are connecting to the Internet and running web browsers, making themselves candidates for remote exploitation. Since most modern web browsers implement a JavaScript runtime environ- ment with a fully-functioning JIT compiler, JIT spraying is a fantastic vector for attacking a browser. However, JIT spraying has historically been limited to the x86 architecture. In this paper, we challenge this trend and show that JIT spraying is indeed a viable attack against ARM.",
            "keywords": [
                "JIT Spraying",
                "ARM Architecture",
                "Code Injection",
                "Gadget Chaining",
                "JavaScriptCore"
            ]
        },
        "url": "URL#4117900",
        "sema_paperId": "704a4d5504edc0b299089aaa4eefa9c7c75e3606"
    },
    {
        "@score": "1",
        "@id": "4117901",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "67/10639",
                        "text": "Kangjie Lu"
                    },
                    {
                        "@pid": "55/4022",
                        "text": "Zhichun Li"
                    },
                    {
                        "@pid": "87/1029",
                        "text": "Vasileios P. Kemerlis"
                    },
                    {
                        "@pid": "87/6581-3",
                        "text": "Zhenyu Wu 0003"
                    },
                    {
                        "@pid": "81/7428",
                        "text": "Long Lu"
                    },
                    {
                        "@pid": "28/9343",
                        "text": "Cong Zheng"
                    },
                    {
                        "@pid": "31/8302",
                        "text": "Zhiyun Qian"
                    },
                    {
                        "@pid": "29/5976",
                        "text": "Wenke Lee"
                    },
                    {
                        "@pid": "47/4422",
                        "text": "Guofei Jiang"
                    }
                ]
            },
            "title": "Checking More and Alerting Less: Detecting Privacy Leakages via Enhanced Data-flow Analysis and Peer Voting.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/LuLKWLZQLJ15",
            "ee": "https://www.ndss-symposium.org/ndss2015/checking-more-and-alerting-less-detecting-privacy-leakages-enhanced-data-flow-analysis-and-peer",
            "url": "https://dblp.org/rec/conf/ndss/LuLKWLZQLJ15",
            "abstract": "Serious concerns have been raised about stealthy disclosures of private user data in smartphone apps, and recent research efforts in mobile security have studied various mechanisms to detect privacy disclosures. However, existing approaches are not effective in informing users and security analysts about potential privacy leakage threats. This is because these methods largely fail to 1) provide highly accurate and inclusive detection of privacy disclosures, and 2) filter out legitimate privacy disclosures that usually dominate detection results and in turn obscure true threats. In this paper, we propose AAPL, an automated system that detects privacy leaks (i.e., truly suspicious privacy disclosures) in Android apps. AAPL is based on multiple special static analysis techniques that we\u2019ve developed for Android apps, including conditional flow identification and joint flow tracking. Furthermore, AAPL employs a new approach called peer voting to filter out most of the legitimate privacy disclosures from the results, purifying the detection results for automatic and easy interpretation. We implemented AAPL and evaluated it over 40, 456 apps. The results indicate that, on average, AAPL achieves an accuracy of 88.7%. For particular disclosures (e.g., contacts), the accuracy is up to 94.6%. Using AAPL, we successfully revealed a collection of unknown privacy leaks. The throughput of our privacy disclosure analysis module is 4.5 apps per minute on a threemachine cluster.",
            "keywords": [
                "Mobile App Privacy",
                "Privacy Leak Detection",
                "Static Analysis",
                "Data-flow Analysis",
                "Peer Voting"
            ]
        },
        "url": "URL#4117901",
        "sema_paperId": "3824fa30a694ae1243c342cd789ec7a879cba255"
    },
    {
        "@score": "1",
        "@id": "4117902",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "161/0676",
                        "text": "Mohamed El Massad"
                    },
                    {
                        "@pid": "94/3807",
                        "text": "Siddharth Garg"
                    },
                    {
                        "@pid": "32/4329",
                        "text": "Mahesh V. Tripunitara"
                    }
                ]
            },
            "title": "Integrated Circuit (IC) Decamouflaging: Reverse Engineering Camouflaged ICs within Minutes.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/MassadGT15",
            "ee": "https://www.ndss-symposium.org/ndss2015/integrated-circuit-ic-decamouflaging-reverse-engineering-camouflaged-ics-within-minutes",
            "url": "https://dblp.org/rec/conf/ndss/MassadGT15",
            "abstract": "Circuit camouflaging is a recently proposed defense mechanism to protect digital integrated circuits (ICs) from reverse engineering attacks by using camouflaged gates, i.e., logic gates whose functionality cannot be precisely determined by the attacker. Recent work appears to establish that an attacker requires time that is exponential in the number of camouflaged gates to reverse engineer a circuit, if the gates that are camouflaged are chosen using a procedure proposed in that work. Consequently, it appears to be the case that even by camouflaging a relatively small number of gates in the circuit, the attacker is forced to undertake several thousands of years of work. In this paper, we refute such claims. With an underlying complexity-theoretic mindset, we show that the same benchmark circuits with the camouflaged gates chosen the same way as prior work, we can decamouflage the circuit in minutes, and not years. As part of constructing our attack, we provide a precise characterization of two problems that the attacker seeks to solve to carry out his attack, and their computational complexity. A composition of solvers for the two problems is our attack procedure. We show that the two problems are co-NP-complete and NP-complete respectively, and our reduction to boolean satisfiability (SAT) and the use of off-the-shelf SAT solvers results in a highly effective attack. We also propose a new notion that we call a discriminating set of input patterns, that soundly captures the attacker\u2019s difficulty. Our extensive empirical studies reveal that the discriminating sets of inputs for realistic circuits are surprising small, thereby providing an explanation for the effectiveness of our attack. We provide additional insights by comparing the procedure of choosing gates to be camouflaged proposed in prior work to simply choosing them randomly. After presenting the results from our attack, we provide insights into the fundamental effectiveness of IC camouflaging. Our work serves as a strong caution to designers of ICs that seek security through IC camouflaging.",
            "keywords": [
                "Integrated Circuit Camouflaging",
                "Reverse Engineering",
                "Decamouflaging",
                "Computational Complexity",
                "Discriminating Input Patterns"
            ]
        },
        "url": "URL#4117902",
        "sema_paperId": "05ee6b24038822f2c90f315bcc979c4744482370"
    },
    {
        "@score": "1",
        "@id": "4117903",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "86/7620",
                        "text": "Vishwath Mohan"
                    },
                    {
                        "@pid": "12/4238",
                        "text": "Per Larsen"
                    },
                    {
                        "@pid": "10/7583-1",
                        "text": "Stefan Brunthaler 0001"
                    },
                    {
                        "@pid": "60/1400",
                        "text": "Kevin W. Hamlen"
                    },
                    {
                        "@pid": "f/MichaelFranz",
                        "text": "Michael Franz"
                    }
                ]
            },
            "title": "Opaque Control-Flow Integrity.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/MohanLBHF15",
            "ee": "https://www.ndss-symposium.org/ndss2015/opaque-control-flow-integrity",
            "url": "https://dblp.org/rec/conf/ndss/MohanLBHF15",
            "abstract": "\u2014A new binary software randomization and Control-Flow Integrity (CFI) enforcement system is presented, which is the \ufb01rst to ef\ufb01ciently resist code-reuse attacks launched by informed adversaries who possess full knowledge of the in-memory code layout of victim programs. The defense mitigates a recent wave of implementation disclosure attacks , by which adversaries can ex\ufb01ltrate in-memory code details in order to prepare code-reuse attacks (e.g., Return-Oriented Programming (ROP) attacks) that bypass \ufb01ne-grained randomization defenses. Such implementation-aware attacks defeat traditional \ufb01ne-grained randomization by undermining its assumption that the randomized locations of abusable code gadgets remain secret. Opaque CFI (O-CFI) overcomes this weakness through a novel combination of \ufb01ne-grained code-randomization and coarse-grained control-\ufb02ow integrity checking. It conceals the graph of hijackable control-\ufb02ow edges even from attackers who can view the complete stack, heap, and binary code of the victim process. For maximal ef\ufb01ciency, the integrity checks are implemented using instructions that will soon be hardware-accelerated on commodity x86-x64 processors. The approach is highly practical since it does not require a modi\ufb01ed compiler and can protect legacy binaries without access to source code. Experiments using our fully functional prototype implementation show that O-CFI provides signi\ufb01cant probabilistic protection against ROP attacks launched by adversaries with complete code layout knowledge, and exhibits only 4.7% mean performance overhead on current hardware (with further overhead reductions to follow on forth-coming Intel processors).",
            "keywords": [
                "Control-Flow Integrity",
                "Code Randomization",
                "Code-Reuse Attacks",
                "Return-Oriented Programming",
                "Implementation Disclosure Attacks"
            ]
        },
        "url": "URL#4117903",
        "sema_paperId": "422c2d83a959df1f7c3e99b8a2c77772d8b2e7c3"
    },
    {
        "@score": "1",
        "@id": "4117904",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "130/1388",
                        "text": "Nitesh Mor"
                    },
                    {
                        "@pid": "53/3712",
                        "text": "Oriana Riva"
                    },
                    {
                        "@pid": "85/6293",
                        "text": "Suman Nath"
                    },
                    {
                        "@pid": "k/JohnKubiatowicz",
                        "text": "John Kubiatowicz"
                    }
                ]
            },
            "title": "Bloom Cookies: Web Search Personalization without User Tracking.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/MorRNK15",
            "ee": "https://www.ndss-symposium.org/ndss2015/bloom-cookies-web-search-personalization-without-user-tracking",
            "url": "https://dblp.org/rec/conf/ndss/MorRNK15",
            "abstract": "We propose Bloom cookies that encode a user\u2019s profile in a compact and privacy-preserving way, without preventing online services from using it for personalization purposes. The Bloom cookies design is inspired by our analysis of a large set of web search logs that shows drawbacks of two profile obfuscation techniques, namely profile generalization and noise injection, today used by many privacy-preserving personalization systems. We find that profile generalization significantly hurts personalization and fails to protect users from a server linking user sessions over time. Noise injection can address these problems, but only at the cost of a high communication overhead and a noise dictionary generated by a trusted third party. In contrast, Bloom cookies leverage Bloom filters as a privacy-preserving data structure to provide a more convenient privacy, personalization, and network efficiency tradeoff: they provide similar (or better) personalization and privacy than noise injection (and profile generalization), but with an order of magnitude lower communication cost and no noise dictionary. We discuss how Bloom cookies can be used for personalized web search, present an algorithm to automatically configure the noise in Bloom cookies given a user\u2019s privacy and personalization goals, and evaluate their performance compared to the state-of-the-art.",
            "keywords": [
                "Web Search Personalization",
                "Privacy-Preserving Techniques",
                "Bloom Cookies",
                "Profile Obfuscation",
                "Communication Efficiency"
            ]
        },
        "url": "URL#4117904",
        "sema_paperId": "5444b5c1135a6558d71d5ab549242b4c889d4916"
    },
    {
        "@score": "1",
        "@id": "4117905",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "128/4640",
                        "text": "Pedro Moreno-Sanchez"
                    },
                    {
                        "@pid": "12/3394",
                        "text": "Aniket Kate"
                    },
                    {
                        "@pid": "25/3571",
                        "text": "Matteo Maffei"
                    },
                    {
                        "@pid": "03/5946",
                        "text": "Kim Pecina"
                    }
                ]
            },
            "title": "Privacy Preserving Payments in Credit Networks: Enabling trust with privacy in online marketplaces.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/Moreno-SanchezK15",
            "ee": "https://www.ndss-symposium.org/ndss2015/privacy-preserving-payments-credit-networks-enabling-trust-privacy-online-marketplaces",
            "url": "https://dblp.org/rec/conf/ndss/Moreno-SanchezK15",
            "abstract": "A credit network models trust between agents in a distributed environment and enables payments between arbitrary pairs of agents. With their flexible design and robustness against intrusion, credit networks form the basis of several Sybil-tolerant social networks, spam-resistant communication protocols, and payment systems. Existing systems, however, expose agents\u2019 trust links as well as the existence and volumes of payment transactions, which is considered sensitive information in social environments or in the financial world. This raises a challenging privacy concern, which has largely been ignored by the research on credit networks so far. This paper presents PrivPay, the first provably secure privacypreserving payment protocol for credit networks. The distinguishing feature of PrivPay is the obliviousness of transactions, which entails strong privacy guarantees for payments. PrivPay does not require any trusted third party, maintains a high accuracy of the transactions, and provides an economical solution to network service providers. It is also general-purpose trusted hardwarebased solution applicable to all credit network-based systems. We implemented PrivPay and demonstrated its practicality by privately emulating transactions performed in the Ripple payment system over a period of four months.",
            "keywords": [
                "Credit Networks",
                "Privacy Preservation",
                "Payment Protocols",
                "Transaction Obliviousness",
                "PrivPay"
            ]
        },
        "url": "URL#4117905",
        "sema_paperId": "e1167e0f5dae02d254af60825be6f493814ee074"
    },
    {
        "@score": "1",
        "@id": "4117906",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "59/749",
                        "text": "Xiang Pan"
                    },
                    {
                        "@pid": "28/8733",
                        "text": "Yinzhi Cao"
                    },
                    {
                        "@pid": "88/2827-4",
                        "text": "Yan Chen 0004"
                    }
                ]
            },
            "title": "I Do Not Know What You Visited Last Summer: Protecting users from stateful third-party web tracking with TrackingFree browser.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/PanCC15",
            "ee": "https://www.ndss-symposium.org/ndss2015/i-do-not-know-what-you-visited-last-summer-protecting-users-third-party-web-tracking",
            "url": "https://dblp.org/rec/conf/ndss/PanCC15",
            "abstract": "Stateful third-party web tracking has drawn the attention of public media given its popularity among top Alexa web sites. A tracking server can associate a unique identifier from the client side with the private information contained in the referer header of the request to the tracking server, thus recording the client\u2019s behavior. Faced with the significant problem, existing works either disable setting tracking identifiers or blacklist third-party requests to certain servers. However, neither of them can completely block stateful web tracking. In this paper, we propose TrackingFree, the first anti-tracking browser by mitigating unique identifiers. Instead of disabling those unique identifiers, we isolate them into different browser principals so that the identifiers still exist but are not unique among different web sites. By doing this, we fundamentally cut off the tracking chain for third-party web tracking. Our evaluation shows that TrackingFree can block all the 647 trackers found in Alexa Top 500 web sites while still preserving web sites\u2019 functionalities, and we formally verified the anti-tracking ability of TrackingFree by Alloy.",
            "pdf_url": "https://www.ndss-symposium.org/wp-content/uploads/2017/09/01_5_0.pdf",
            "keywords": [
                "Web Tracking",
                "Privacy Protection",
                "Anti-Tracking",
                "Unique Identifiers",
                "TrackingFree Browser"
            ]
        },
        "url": "URL#4117906",
        "sema_paperId": "504a85afb6d69a835b62a1ac25e6b1ab80527f36"
    },
    {
        "@score": "1",
        "@id": "4117907",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "148/4161",
                        "text": "Timothy Peters"
                    },
                    {
                        "@pid": "31/2655",
                        "text": "Mark A. Gondree"
                    },
                    {
                        "@pid": "54/2978",
                        "text": "Zachary N. J. Peterson"
                    }
                ]
            },
            "title": "DEFY: A Deniable, Encrypted File System for Log-Structured Storage.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/PetersGP15",
            "ee": "https://www.ndss-symposium.org/ndss2015/defy-deniable-encrypted-file-system-log-structured-storage",
            "url": "https://dblp.org/rec/conf/ndss/PetersGP15",
            "abstract": "While solutions for file system encryption can pre- vent an adversary from determining the contents of files, in situations where a user wishes to hide the existence of data, encryption alone is not sufficient. Indeed, encryption may draw attention to those files, as they may likely contain information the user wishes to keep secret. Consequently, adversarial coercion may motivate the owner to surrender their encryption keys, under duress. This paper presents DEFY, a deniable file system following a log-structured design. Maintaining a log-structure is motivated by the technical constraints imposed by solid-state drives, such as those found in mobile devices. These devices have consequential properties that previous work largely ignores. Further, DEFY provides features not offered by prior work, including: authenticated encryption, fast secure deletion, and support for multiple layers of deniability. We consider security against a snapshot adversary, the strongest deniable filesystem adversary considered by prior literature. We have implemented a prototype based on YAFFS and an evaluation shows DEFY exhibits performance degradation comparable to the encrypted file system for flash, WhisperYAFFS.",
            "keywords": [
                "Deniable File Systems",
                "Encrypted File Systems",
                "Log-Structured Storage",
                "Adversarial Coercion",
                "Authenticated Encryption"
            ]
        },
        "url": "URL#4117907",
        "sema_paperId": "170da923ef470de4027c010fd7e002df3b221a08"
    },
    {
        "@score": "1",
        "@id": "4117908",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "48/3729",
                        "text": "Phillip A. Porras"
                    },
                    {
                        "@pid": "03/2647",
                        "text": "Steven Cheung"
                    },
                    {
                        "@pid": "73/5519",
                        "text": "Martin W. Fong"
                    },
                    {
                        "@pid": "14/903",
                        "text": "Keith Skinner"
                    },
                    {
                        "@pid": "75/3570",
                        "text": "Vinod Yegneswaran"
                    }
                ]
            },
            "title": "Securing the Software Defined Network Control Layer.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/PorrasCFSY15",
            "ee": "https://www.ndss-symposium.org/ndss2015/securing-software-defined-network-control-layer",
            "url": "https://dblp.org/rec/conf/ndss/PorrasCFSY15",
            "abstract": "Software-defined networks (SDNs) pose both an opportunity and challenge to the network security community. The opportunity lies in the ability of SDN applications to express intelligent and agile threat mitigation logic against hostile flows, without the need for specialized inline hardware. However, the SDN community lacks a secure control-layer to manage the interactions between the application layer and the switch infrastructure (the data plane). There are no available SDN controllers that provide the key security features, trust models, and policy mediation logic, necessary to deploy multiple SDN applications into a highly sensitive computing environment. We propose the design of security extensions at the control layer to provide the security management and arbitration of conflicting flow rules that arise when multiple applications are deployed within the same network. We present a prototype of our design as a Security Enhanced version of the widely used OpenFlow Floodlight Controller, which we call SE-Floodlight. SE-Floodlight extends Floodlight with a security-enforcement kernel (SEK) layer, whose functions are also directly applicable to other OpenFlow controllers. The SEK adds a unique set of secure application management features, including an authentication service, role-based authorization, a permission model for mediating all configuration change requests to the data-plane, inline flow-rule conflict resolution, and a security audit service. We demonstrate the robustness and scalability of our system implementation through both a comprehensive functionality assessment and a performance evaluation that illustrates its sub-linear scaling properties.",
            "keywords": [
                "Software-Defined Networking",
                "Control Layer Security",
                "Flow Rule Management",
                "Security Enhanced Floodlight",
                "Application Conflict Resolution"
            ]
        },
        "url": "URL#4117908",
        "sema_paperId": "24c2ed6a87dc09f12e34a7a1d3a1595d7dc31c6e"
    },
    {
        "@score": "1",
        "@id": "4117909",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "127/9208",
                        "text": "Aravind Prakash"
                    },
                    {
                        "@pid": "148/1333",
                        "text": "Xunchao Hu"
                    },
                    {
                        "@pid": "77/6178-1",
                        "text": "Heng Yin 0001"
                    }
                ]
            },
            "title": "vfGuard: Strict Protection for Virtual Function Calls in COTS C++ Binaries.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/PrakashHY15",
            "ee": "https://www.ndss-symposium.org/ndss2015/vfguard-strict-protection-virtual-function-calls-cots-c-binaries",
            "url": "https://dblp.org/rec/conf/ndss/PrakashHY15",
            "abstract": "Control-Flow Integrity (CFI) is an important security property that needs to be enforced to prevent controlflow hijacking attacks. Recent attacks have demonstrated that existing CFI protections for COTS binaries are too permissive, and vulnerable to sophisticated code reusing attacks. Accounting for control flow restrictions imposed at higher levels of semantics is key to increasing CFI precision. In this paper, we aim to provide more stringent protection for virtual function calls in COTS C++ binaries by recovering C++ level semantics. To achieve this goal, we recover C++ semantics, including VTables and virtual callsites. With the extracted C++ semantics, we construct a sound CFI policy and further improve the policy precision by devising two filters, namely \u201cNested Call Filter\u201d and \u201cCalling Convention Filter\u201d. We implement a prototype system called vfGuard, and evaluate its accuracy, precision, effectiveness, coverage and performance overhead against a test set including complex C++ binary modules used by Internet Explorer. Our experiments show a runtime overhead of 18.3% per module. On SpiderMonkey, an open-source JavaScript engine used by Firefox, vfGuard generated 199 call targets per virtual callsite \u2013 within the same order of magnitude as those generated from a source code based solution. The policies constructed by vfGuard are sound and of higher precision when compared to state-of-the-art binary-only CFI solutions.",
            "keywords": [
                "Control-Flow Integrity",
                "COTS C++ Binaries",
                "Virtual Function Calls",
                "CFI Policy",
                "Code Reuse Attacks"
            ]
        },
        "url": "URL#4117909",
        "sema_paperId": "3ca72e613e652cce2d4349878f1663d4f518059c"
    },
    {
        "@score": "1",
        "@id": "4117910",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "119/7712",
                        "text": "Yan Shoshitaishvili"
                    },
                    {
                        "@pid": "127/9829",
                        "text": "Ruoyu Wang 0001"
                    },
                    {
                        "@pid": "28/10586",
                        "text": "Christophe Hauser"
                    },
                    {
                        "@pid": "k/ChristopherKruegel",
                        "text": "Christopher Kruegel"
                    },
                    {
                        "@pid": "v/GiovanniVigna",
                        "text": "Giovanni Vigna"
                    }
                ]
            },
            "title": "Firmalice - Automatic Detection of Authentication Bypass Vulnerabilities in Binary Firmware.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/Shoshitaishvili15",
            "ee": "https://www.ndss-symposium.org/ndss2015/firmalice-automatic-detection-authentication-bypass-vulnerabilities-binary-firmware",
            "url": "https://dblp.org/rec/conf/ndss/Shoshitaishvili15",
            "abstract": "\u2014Embedded devices have become ubiquitous, and they are used in a range of privacy-sensitive and security-critical applications. Most of these devices run proprietary software, and little documentation is available about the software\u2019s inner workings. In some cases, the cost of the hardware and protection mechanisms might make access to the devices themselves infeasible. Analyzing the software that is present in such environments is challenging, but necessary, if the risks associated with software bugs and vulnerabilities must be avoided. As a matter of fact, recent studies revealed the presence of backdoors in a number of embedded devices available on the market. In this paper, we present Firmalice, a binary analysis framework to support the analysis of \ufb01rmware running on embedded devices. Firmalice builds on top of a symbolic execution engine, and techniques, such as program slicing, to increase its scalability. Furthermore, Firmalice utilizes a novel model of authentication bypass \ufb02aws, based on the attacker\u2019s ability to determine the required inputs to perform privileged operations. We evaluated Firmalice on the \ufb01rmware of three commercially-available devices, and were able to detect authentication bypass backdoors in two of them. Additionally, Firmalice was able to determine that the backdoor in the third \ufb01rmware sample was not exploitable by an attacker without knowledge of a set of unprivileged credentials.",
            "keywords": [
                "Embedded Device Security",
                "Firmware Analysis",
                "Authentication Bypass",
                "Binary Analysis Framework",
                "Backdoor Detection"
            ]
        },
        "url": "URL#4117910",
        "sema_paperId": "c80c9b965fb42ebf68c9848e78fe7352ab42b33c"
    },
    {
        "@score": "1",
        "@id": "4117911",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "69/6818",
                        "text": "Chengyu Song"
                    },
                    {
                        "@pid": "94/3019-8",
                        "text": "Chao Zhang 0008"
                    },
                    {
                        "@pid": "08/7063",
                        "text": "Tielei Wang"
                    },
                    {
                        "@pid": "29/5976",
                        "text": "Wenke Lee"
                    },
                    {
                        "@pid": "97/6582",
                        "text": "David Melski"
                    }
                ]
            },
            "title": "Exploiting and Protecting Dynamic Code Generation.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/SongZWLM15",
            "ee": "https://www.ndss-symposium.org/ndss2015/exploiting-and-protecting-dynamic-code-generation",
            "url": "https://dblp.org/rec/conf/ndss/SongZWLM15",
            "abstract": "Abstract\u2014Many mechanisms have been proposed and de-ployed to prevent exploits against software vulnerabilities. Amongthem, W X is one of the most effective and ef\ufb01cient. W Xprevents memory pages from being simultaneously writableand executable, rendering the decades old shellcode injectiontechnique infeasible.In this paper, we demonstrate that the traditional shellcodeinjection attack can be revived through a code cache injectiontechnique. Speci\ufb01cally, dynamic code generation, a techniquewidely used in just-in-time (JIT) compilation and dynamic binarytranslation (DBT), generates and modi\ufb01es code on the \ufb02y in orderto promote performance or security. The dynamically generatedcode fragments are stored in a code cache, which is writableand executable either at the same time or alternately, resultingin an opportunity for exploitation. This threat is especiallyrealistic when the generated code is multi-threaded, becauseswitching between writable and executable leaves a time windowfor exploitation. To illustrate this threat, we have crafted a proof-of-concept exploit against modern browsers that support WebWorkers.To mitigate this code cache injection threat, we propose anew dynamic code generation architecture. This new architecturerelocates the dynamic code generator to a separate process,in which the code cache is writable. In the original processwhere the generated code executes, the code cache remains read-only. The code cache is synchronized across the writing processand the execution process through shared memory. Interactionbetween the code generator and the generated code is handledtransparently through remote procedure calls (RPC). We haveported the Google V8 JavaScript engine and the Strata DBTto this new architecture. Our implementation experience showedthat the engineering effort for porting to this new architectureis minimal. Evaluation of our prototype implementation showedthat this new architecture can defeat the code cache injectionattack with small performance overhead.",
            "keywords": [
                "Dynamic Code Generation",
                "Code Cache Injection",
                "Just-in-Time Compilation",
                "Memory Protection",
                "Exploitation Mitigation"
            ]
        },
        "url": "URL#4117911",
        "sema_paperId": "eb801bffcdbd93efba42f71eaa478c1de9666361"
    },
    {
        "@score": "1",
        "@id": "4117912",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "161/0606",
                        "text": "Kimberly Tam"
                    },
                    {
                        "@pid": "161/0630",
                        "text": "Salahuddin J. Khan"
                    },
                    {
                        "@pid": "87/8262",
                        "text": "Aristide Fattori"
                    },
                    {
                        "@pid": "95/5162",
                        "text": "Lorenzo Cavallaro"
                    }
                ]
            },
            "title": "CopperDroid: Automatic Reconstruction of Android Malware Behaviors.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/TamKFC15",
            "ee": "https://www.ndss-symposium.org/ndss2015/copperdroid-automatic-reconstruction-android-malware-behaviors",
            "url": "https://dblp.org/rec/conf/ndss/TamKFC15",
            "abstract": "Mobile devices and their application marketplaces drive the entire economy of the today's mobile landscape. Android platforms alone have produced staggering revenues, exceeding five billion USD, which has attracted cybercriminals and increased malware in Android markets at an alarming rate. To better understand this slew of threats, we present CopperDroid, an automatic VMI-based dynamic analysis system to reconstruct the behaviors of Android malware. The novelty of CopperDroid lies in its agnostic approach to identify interesting OS- and high-level Android-specific behaviors. It reconstructs these behaviors by observing and dissecting system calls and, therefore, is resistant to the multitude of alterations the Android runtime is subjected to over its life-cycle. CopperDroid automatically and accurately reconstructs events of interest that describe, not only well-known process-OS interactions (e.g., file and process creation), but also complex intra- and inter-process communications (e.g., SMS reception), whose semantics are typically contextualized through complex Android objects. Because CopperDroid's reconstruction mechanisms are agnostic to the underlying action invocation methods, it is able to capture actions initiated both from Java and native code execution. CopperDroid's analysis generates detailed behavioral profiles that abstract a large stream of low-level\u2014often uninteresting\u2014events into concise, high-level semantics, which are well-suited to provide insightful behavioral traits and open the possibility to further research directions. We carried out an extensive evaluation to assess the capabilities and performance of CopperDroid on more than 2,900 Android malware samples. Our experiments show that CopperDroid faithfully reconstructs OS- and Android-specific behaviors. Additionally, we demonstrate how CopperDroid can be leveraged to disclose additional behaviors through the use of a simple, yet effective, app stimulation technique. Using this technique, we successfully triggered and disclosed additional behaviors on more than 60% of the analyzed malware samples. This qualitatively demonstrates the versatility of CopperDroid's ability to improve dynamic-based code coverage.",
            "keywords": [
                "Android Malware Analysis",
                "Dynamic Analysis",
                "Behavior Reconstruction",
                "Virtual Machine Introspection (VMI)",
                "Malware Detection Techniques"
            ]
        },
        "url": "URL#4117912",
        "sema_paperId": "b38fd5f9ec3ce75455946de5913549b5f660b22e"
    },
    {
        "@score": "1",
        "@id": "4117913",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "122/8629",
                        "text": "Pierre-Antoine Vervier"
                    },
                    {
                        "@pid": "19/511",
                        "text": "Olivier Thonnard"
                    },
                    {
                        "@pid": "76/5806",
                        "text": "Marc Dacier"
                    }
                ]
            },
            "title": "Mind Your Blocks: On the Stealthiness of Malicious BGP Hijacks.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/VervierTD15",
            "ee": "https://www.ndss-symposium.org/ndss2015/mind-your-blocks-stealthiness-malicious-bgp-hijacks",
            "url": "https://dblp.org/rec/conf/ndss/VervierTD15",
            "abstract": "Some recent research presented evidence of blocks of IP addresses being stolen by BGP hijackers to launch spam campaigns (35). This was the first time BGP hijacks were seen in the wild. Since then, only a very few anecdotal cases have been reported as if hackers were not interested in running these attacks. However, it is a common belief among network operators and ISPs that these attacks could be taking place but, so far, no one has produced evidence to back up that claim. In this paper, we analyse 18 months of data collected by an infrastructure specifically built to answer that question: are intentional stealthy BGP hijacks routinely taking place in the Internet? The identification of what we believe to be more than 2,000 malicious hijacks leads to a positive answer. The lack of ground truth is, of course, a problem but we managed to get confirmation of some of our findings thanks to an ISP unwittingly involved in hijack cases we have spotted. This paper aims at being an eye opener for the community by shedding some light on this undocumented threat. We also hope that it will spur new research to understand why these hijacks are taking place and how they can be mitigated. Depending on how BGP attacks are carried out, they can be very disruptive for the whole Internet and should be looked at very closely. As of today, as much as 20% of the whole IPv4 address space is currently allocated but not publicly announced, which makes it potentially vulnerable to such malicious BGP hijacks.",
            "keywords": [
                "BGP Hijacking",
                "Network Security",
                "Malicious Attacks",
                "IP Address Theft",
                "Stealthy Hijacks"
            ]
        },
        "url": "URL#4117913",
        "sema_paperId": "496e09594a920a0027fd6a65481c091d61692304"
    },
    {
        "@score": "1",
        "@id": "4117914",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "145/1094",
                        "text": "Thomas Vissers"
                    },
                    {
                        "@pid": "13/86",
                        "text": "Wouter Joosen"
                    },
                    {
                        "@pid": "04/8280",
                        "text": "Nick Nikiforakis"
                    }
                ]
            },
            "title": "Parking Sensors: Analyzing and Detecting Parked Domains.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/VissersJN15",
            "ee": "https://www.ndss-symposium.org/ndss2015/parking-sensors-analyzing-and-detecting-parked-domains",
            "url": "https://dblp.org/rec/conf/ndss/VissersJN15",
            "abstract": "A parked domain is an undeveloped domain which has no content other than automatically computed advertising banners and links, used to generate profit. Despite the apparent popularity of this practice, little is known about parked domains and domain parking services that assist domain owners in parking and monetizing unused domains. This paper presents and in-depth exploration of the ecosystem of domain parking services from a security point of view, focusing mostly on the consequences for everyday users who land on parked pages. By collecting data from over 8 million parked domains, we are able to map out the entities that constitute the ecosystem, thus allowing us to analyze the domain owners, parking services, and advertisement syndicators involved. We show that users who land on parked websites are exposed to malware, inappropriate content, and elaborate scams, such as fake antivirus warnings and costly remote \u201ctechnicians\u201d. At the same time, we find a significant number of parked domains to be abusing popular names and trademarks through typosquatting and through domain names confusingly similar to authoritative ones. Given the extent of observed abuse, we propose a set of features that are representative of parked pages and build a robust client-side classifier which achieves high accuracy with a negligible percentage of false positives.",
            "keywords": [
                "Parked Domains",
                "Domain Parking Services",
                "Malware Exposure",
                "Typosquatting",
                "Advertisement Syndication"
            ]
        },
        "url": "URL#4117914",
        "sema_paperId": "353bc95ea6d720d867489e3d4cf5c9427531c7c7"
    },
    {
        "@score": "1",
        "@id": "4117915",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "150/9448",
                        "text": "Riad S. Wahby"
                    },
                    {
                        "@pid": "68/8463",
                        "text": "Srinath T. V. Setty"
                    },
                    {
                        "@pid": "132/0854",
                        "text": "Zuocheng Ren"
                    },
                    {
                        "@pid": "93/1054",
                        "text": "Andrew J. Blumberg"
                    },
                    {
                        "@pid": "00/2879",
                        "text": "Michael Walfish"
                    }
                ]
            },
            "title": "Efficient RAM and control flow in verifiable outsourced computation.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/WahbySRBW15",
            "ee": "https://www.ndss-symposium.org/ndss2015/efficient-ram-and-control-flow-verifiable-outsourced-computation",
            "url": "https://dblp.org/rec/conf/ndss/WahbySRBW15",
            "abstract": "Recent work on proof-based verifiable computation has resulted in built systems that employ tools from complexity theory and cryptography to address a basic problem in systems security: allowing a local computer to outsource the execution of a program while providing the local computer with a guarantee of integrity and the remote computer with a guarantee of privacy. However, support for programs that use RAM and control flow has been problematic. State of the art systems either restrict the use of these constructs (e.g., requiring static loop bounds), incur sizeable overhead on every step, or pay tremendous costs when the constructs are invoked. This paper describes Buffet, a built system that solves these problems by providing inexpensive \u201ca la carte\u201d RAM and dynamic control flow. Buffet composes an elegant prior approach to RAM with a novel adaptation of techniques from the compilers literature. Buffet allows the programmer to express programs in an expansive subset of C (disallowing only \u201cgoto\u201d and function pointers), can handle essentially any example in the verifiable computation literature, and achieves the best performance in the area by multiple orders of magnitude.",
            "keywords": [
                "Verifiable Computation",
                "Outsourced Computation",
                "RAM",
                "Dynamic Control Flow",
                "Performance Optimization"
            ]
        },
        "url": "URL#4117915",
        "sema_paperId": "c7fc43122993c0f3c2cbdee55427f4f551c64582"
    },
    {
        "@score": "1",
        "@id": "4117916",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "60/8494",
                        "text": "Xueqiang Wang"
                    },
                    {
                        "@pid": "30/3530-1",
                        "text": "Kun Sun 0001"
                    },
                    {
                        "@pid": "01/3425",
                        "text": "Yuewu Wang"
                    },
                    {
                        "@pid": "70/3282",
                        "text": "Jiwu Jing"
                    }
                ]
            },
            "title": "DeepDroid: Dynamically Enforcing Enterprise Policy on Android Devices.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/WangSWJ15",
            "ee": "https://www.ndss-symposium.org/ndss2015/deepdroid-dynamically-enforcing-enterprise-policy-android-devices",
            "url": "https://dblp.org/rec/conf/ndss/WangSWJ15",
            "abstract": "It is becoming a global trend for company employees equipped with mobile devices to access company\u2019s assets. Besides enterprise apps, lots of personal apps from various untrusted app stores may also be installed on those devices. To secure the business environment, policy enforcement on what, how, and when certain apps can access system resources is required by enterprise IT. However, Android, the largest mobile platform with a market share of 81.9%, provides very restricted interfaces for enterprise policy enforcement. In this paper, we present DeepDroid, a dynamic enterprise security policy enforcement scheme on Android devices. Different from existing approaches, DeepDroid is implemented by dynamic memory instrumentation of a small number of critical system processes without any firmware modification. DeepDroid can be easily deployed on various smartphone platforms with a wide range of Android versions. Moreover, based on the context information extracted from Binder interception, a fine-grained policy can be enforced. We develop a prototype of DeepDroid and test it on various smartphones and Android versions. The experimental results show that DeepDroid can effectively enforce enterprise resource access policies with negligible performance overhead.",
            "keywords": [
                "Android Security",
                "Enterprise Policy Enforcement",
                "Dynamic Memory Instrumentation",
                "Resource Access Control",
                "Context-Aware Policy Enforcement"
            ]
        },
        "url": "URL#4117916",
        "sema_paperId": "ca5c4ff113b7c7bee61b4bed1b8788da55299db7"
    },
    {
        "@score": "1",
        "@id": "4117917",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "140/0794",
                        "text": "Khaled Yakdan"
                    },
                    {
                        "@pid": "64/11235",
                        "text": "Sebastian Eschweiler"
                    },
                    {
                        "@pid": "61/2236",
                        "text": "Elmar Gerhards-Padilla"
                    },
                    {
                        "@pid": "88/5808-1",
                        "text": "Matthew Smith 0001"
                    }
                ]
            },
            "title": "No More Gotos: Decompilation Using Pattern-Independent Control-Flow Structuring and Semantic-Preserving Transformations.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/YakdanEGS15",
            "ee": "https://www.ndss-symposium.org/ndss2015/no-more-gotos-decompilation-using-pattern-independent-control-flow-structuring-and-semantics",
            "url": "https://dblp.org/rec/conf/ndss/YakdanEGS15",
            "abstract": "Decompilation is important for many security applications; it facilitates the tedious task of manual malware reverse engineering and enables the use of source-based security tools on binary code. This includes tools to find vulnerabilities, discover bugs, and perform taint tracking. Recovering high-level control constructs is essential for decompilation in order to produce structured code that is suitable for human analysts and sourcebased program analysis techniques. State-of-the-art decompilers rely on structural analysis, a pattern-matching approach over the control flow graph, to recover control constructs from binary code. Whenever no match is found, they generate goto statements and thus produce unstructured decompiled output. Those statements are problematic because they make decompiled code harder to understand and less suitable for program analysis. In this paper, we present DREAM, the first decompiler to offer a goto-free output. DREAM uses a novel patternindependent control-flow structuring algorithm that can recover all control constructs in binary programs and produce structured decompiled code without any goto statement. We also present semantics-preserving transformations that can transform unstructured control flow graphs into structured graphs. We demonstrate the correctness of our algorithms and show that we outperform both the leading industry and academic decompilers: Hex-Rays and Phoenix. We use the GNU coreutils suite of utilities as a benchmark. Apart from reducing the number of goto statements to zero, DREAM also produced more compact code (less lines of code) for 72.7% of decompiled functions compared to Hex-Rays and 98.8% compared to Phoenix. We also present a comparison of Hex-Rays and DREAM when decompiling three samples from Cridex, ZeusP2P, and SpyEye malware families.",
            "keywords": [
                "Decompilation",
                "Control Flow Structuring",
                "Binary Code Analysis",
                "Semantic-Preserving Transformations",
                "Goto-Free Output"
            ]
        },
        "url": "URL#4117917",
        "sema_paperId": "c1a02442b6c34d994f90eab697b924db3376991f"
    },
    {
        "@score": "1",
        "@id": "4117918",
        "info": {
            "authors": {
                "author": {
                    "@pid": "21/2957",
                    "text": "Yves Younan"
                }
            },
            "title": "FreeSentry: protecting against use-after-free vulnerabilities due to dangling pointers.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/Younan15",
            "ee": "https://www.ndss-symposium.org/ndss2015/freesentry-protecting-against-use-after-free-vulnerabilities-due-dangling-pointers",
            "url": "https://dblp.org/rec/conf/ndss/Younan15",
            "abstract": "Use-after-free vulnerabilities have become an important class of security problems due to the existence of mitigations that protect against other types of vulnerabilities. The effects of their exploitation can be just as devastating as exploiting a buffer overflow, potentially resulting in full code execution within the vulnerable program. Few protections exist against these types of vulnerabilities and they are particularly hard to discover through manual code inspection. In this paper we present FreeSentry: a mitigation that protects against use-after-free vulnerabilities by inserting dynamic runtime checks that invalidate pointers when the associated memory is released. If such an invalidated pointer is accessed, the program will subsequently crash, preventing an attacker from exploiting the vulnerability. When checking dynamically allocated memory, our approach has a moderate performance overhead on the SPEC CPU benchmarks: running with a geometric mean performance impact of around 25%. It has no overhead when deployed on widely used server side daemons such as OpenSSH or the Apache HTTP daemon. FreeSentry also discovered a previously unknown use-after-free vulnerability in one of the programs in SPEC CPU2000 benchmarks: perlbmk. This vulnerability seems to have been missed by other mitigations.",
            "keywords": [
                "Use-After-Free Vulnerabilities",
                "Dynamic Runtime Checks",
                "Memory Management",
                "Dangling Pointers",
                "Security Mitigation"
            ]
        },
        "url": "URL#4117918",
        "sema_paperId": "3829df26d4ce686251b9b5030893febd75162539"
    },
    {
        "@score": "1",
        "@id": "4117919",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "94/3019-8",
                        "text": "Chao Zhang 0008"
                    },
                    {
                        "@pid": "69/6818",
                        "text": "Chengyu Song"
                    },
                    {
                        "@pid": "88/10074",
                        "text": "Kevin Zhijie Chen"
                    },
                    {
                        "@pid": "50/10188",
                        "text": "Zhaofeng Chen"
                    },
                    {
                        "@pid": "s/DXSong",
                        "text": "Dawn Song"
                    }
                ]
            },
            "title": "VTint: Protecting Virtual Function Tables&apos; Integrity.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/ZhangSCCS15",
            "ee": "https://www.ndss-symposium.org/ndss2015/vtint-protecting-virtual-function-tables-integrity",
            "url": "https://dblp.org/rec/conf/ndss/ZhangSCCS15",
            "abstract": "In the recent past, a number of approaches have been proposed to protect certain types of control data in a program, such as return addresses saved on the stack, rendering most traditional control flow hijacking attacks ineffective. Attack- ers, however, can bypass these defenses by launching advanced attacks that corrupt other data, e.g., pointers indirectly used to access code. One of the most popular targets is virtual table pointers (vfptr), which point to virtual function tables (vtable) consisting of virtual function pointers. Attackers can exploit vul- nerabilities, such as use-after-free and heap overflow, to overwrite the vtable or vfptr, causing further virtual function calls to be hijacked (vtable hijacking). In this paper we propose a lightweight defense solution VTint to protect binary executables against vtable hijacking attacks. It uses binary rewriting to instrument security checks before virtual function dispatches to validate vtables' integrity. Experiments show that it only introduces a low performance overhead (less than 2%), and it can effectively protect real-world vtable hijacking attacks.",
            "keywords": [
                "Binary Rewriting",
                "Vtable Hijacking",
                "Virtual Function Tables",
                "Security Checks",
                "Memory Corruption"
            ]
        },
        "url": "URL#4117919",
        "sema_paperId": "57298d1fcb492f1785f7c912c4d18fa4663d8595"
    },
    {
        "@score": "1",
        "@id": "4117920",
        "info": {
            "authors": {
                "author": [
                    {
                        "@pid": "140/6495",
                        "text": "Lianying Zhao"
                    },
                    {
                        "@pid": "m/MohammadMannan",
                        "text": "Mohammad Mannan"
                    }
                ]
            },
            "title": "Gracewipe: Secure and Verifiable Deletion under Coercion.",
            "venue": "NDSS",
            "year": "2015",
            "type": "Conference and Workshop Papers",
            "access": "open",
            "key": "conf/ndss/ZhaoM15",
            "ee": "https://www.ndss-symposium.org/ndss2015/gracewipe-secure-and-verifiable-deletion-under-coercion",
            "url": "https://dblp.org/rec/conf/ndss/ZhaoM15",
            "abstract": "\u2014For users in possession of password-protected encrypted data in persistent storage (i.e., \u201cdata at rest\u201d), an obvious problem is that the password may be extracted by an adversary through dictionary attacks or by coercing the user. Techniques such as multi-level hidden volumes with plausible deniability, or software/hardware-based full disk encryption (FDE) cannot adequately address such an attacker. For these threats, making data veri\ufb01ably inaccessible in a quick fashion may be the preferred choice, speci\ufb01cally for users such as government/corporate agents, journalists, and human rights activists with highly con\ufb01dential secrets, when caught and interrogated in a hostile territory. Using secure storage on a Trusted Platform Module (TPM) and modern CPU\u2019s trusted execution mode (e.g., Intel TXT), we design Gracewipe to enable secure and veri\ufb01able deletion of encryption keys through a special deletion password. An attacker cannot distinguish between a deletion and real password. He can guess the real password to unlock the target encryption key only through the valid Gracewipe environment; guessing the deletion password will trigger deletion of the real key. When coerced, a user can fake compliance, and enter the deletion password; and then the user can prove to the attacker that Gracewipe has been executed and the real key is no longer available (through a TPM quote), hoping that a reasonable adversary then will \ufb01nd no reason to keep holding the victim, and may even release her. We implement two prototypes of Gracewipe: software-based FDE system with plausible deniability (using TrueCrypt with hidden volume), and hardware-based FDE (using a Seagate self-encrypting drive (SED)). Our choice of booting Windows at the end of a Gracewipe session (for the possibility of immediate adoption), poses some unique challenges. Through the design and prototypes of Gracewipe, we hope to raise awareness of a special but critical use-case of FDE systems.",
            "keywords": [
                "Secure Deletion",
                "Encryption Keys",
                "Trusted Platform Module (TPM)",
                "Coercion Resistance",
                "Plausible Deniability"
            ]
        },
        "url": "URL#4117920",
        "sema_paperId": "81716972d93b4781f828c3d381ba0429f823b5cb"
    },
    {
        "@score": "1",
        "@id": "4158017",
        "info": {
            "title": "22nd Annual Network and Distributed System Security Symposium, NDSS 2015, San Diego, California, USA, February 8-11, 2015",
            "venue": "NDSS",
            "publisher": "The Internet Society",
            "year": "2015",
            "type": "Editorship",
            "access": "open",
            "key": "conf/ndss/2015",
            "ee": "https://www.ndss-symposium.org/ndss2015/",
            "url": "https://dblp.org/rec/conf/ndss/2015",
            "abstract": null
        },
        "url": "URL#4158017",
        "sema_paperId": "be70222ca20f45547766e6976b43ff992e70d06f"
    }
]